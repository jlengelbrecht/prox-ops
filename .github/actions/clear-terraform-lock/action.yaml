name: Clear Terraform State Lock
description: Detect and clear stale Terraform locks using error output parsing (S3 native locking compatible)

inputs:
  terraform_state_bucket:
    description: S3 bucket name containing Terraform state
    required: true
  terraform_state_key:
    description: S3 state file key (e.g., terraform.tfstate)
    required: false
    default: terraform.tfstate
  proxmox_username:
    description: Proxmox username for Terraform authentication
    required: true
  proxmox_password:
    description: Proxmox password/token for Terraform authentication
    required: true
  github_repository:
    description: GitHub repository name for error messages
    required: true
  lock_age_threshold_minutes:
    description: Minimum age (in minutes) before a lock is considered stale
    required: false
    default: "5"
  max_retry_attempts:
    description: Maximum retry attempts after clearing lock
    required: false
    default: "3"

outputs:
  lock_cleared:
    description: Whether a lock was detected and cleared
    value: ${{ steps.detect-and-clear.outputs.lock_cleared }}
  lock_id:
    description: The lock ID that was cleared (if any)
    value: ${{ steps.detect-and-clear.outputs.lock_id }}

runs:
  using: composite
  steps:
    - name: Detect and clear stale Terraform locks
      id: detect-and-clear
      shell: bash
      working-directory: ./terraform
      env:
        TF_VAR_proxmox_username: ${{ inputs.proxmox_username }}
        TF_VAR_proxmox_password: ${{ inputs.proxmox_password }}
        LOCK_AGE_THRESHOLD: ${{ inputs.lock_age_threshold_minutes }}
        MAX_RETRIES: ${{ inputs.max_retry_attempts }}
        STATE_BUCKET: ${{ inputs.terraform_state_bucket }}
        STATE_KEY: ${{ inputs.terraform_state_key }}
        GITHUB_REPO: ${{ inputs.github_repository }}
      run: |
        set -euo pipefail

        echo "=============================================="
        echo "Terraform Lock Detection and Clearing"
        echo "=============================================="
        echo "Backend: s3://${STATE_BUCKET}/${STATE_KEY}"
        echo "Lock age threshold: ${LOCK_AGE_THRESHOLD} minutes"
        echo "Max retry attempts: ${MAX_RETRIES}"
        echo ""

        # Initialize outputs
        echo "lock_cleared=false" >> "$GITHUB_OUTPUT"
        echo "lock_id=" >> "$GITHUB_OUTPUT"

        #######################################################################
        # FUNCTION: Parse lock info from Terraform error output
        #######################################################################
        parse_lock_info() {
          local error_output="$1"

          # Extract lock ID (format: "ID:        <uuid>")
          LOCK_ID=$(echo "$error_output" | grep -oP 'ID:\s*\K[a-f0-9-]{36}' | head -1 || true)

          # Extract creation time (format: "Created:   2026-01-03 04:58:39.123456 +0000 UTC")
          LOCK_CREATED=$(echo "$error_output" | grep -oP 'Created:\s*\K\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}' | head -1 || true)

          # Extract who holds the lock
          LOCK_WHO=$(echo "$error_output" | grep -oP 'Who:\s*\K\S+' | head -1 || true)

          # Extract operation type
          LOCK_OPERATION=$(echo "$error_output" | grep -oP 'Operation:\s*\K\S+' | head -1 || true)

          # Export for use in caller
          export LOCK_ID LOCK_CREATED LOCK_WHO LOCK_OPERATION
        }

        #######################################################################
        # FUNCTION: Calculate lock age in minutes
        #######################################################################
        calculate_lock_age() {
          local created="$1"

          if [ -z "$created" ]; then
            echo "0"
            return
          fi

          local current_epoch
          local lock_epoch

          current_epoch=$(date -u +%s)

          # Try GNU date first (Linux)
          if lock_epoch=$(date -u -d "$created" +%s 2>/dev/null); then
            echo $(( (current_epoch - lock_epoch) / 60 ))
          # Fall back to Python for macOS or other systems
          elif command -v python3 &>/dev/null; then
            lock_epoch=$(python3 -c "
import sys
from datetime import datetime
try:
    dt = datetime.strptime(sys.argv[1], '%Y-%m-%d %H:%M:%S')
    print(int(dt.timestamp()))
except:
    print('0')
" "$created" 2>/dev/null || echo "0")
            if [ "$lock_epoch" != "0" ]; then
              echo $(( (current_epoch - lock_epoch) / 60 ))
            else
              echo "0"
            fi
          else
            echo "0"
          fi
        }

        #######################################################################
        # FUNCTION: Attempt to clear lock
        #######################################################################
        clear_lock() {
          local lock_id="$1"
          local lock_age="$2"

          echo ""
          echo "=============================================="
          echo "STALE LOCK DETECTED"
          echo "=============================================="
          echo "Lock ID:     $lock_id"
          echo "Lock Age:    $lock_age minutes"
          echo "Who:         ${LOCK_WHO:-unknown}"
          echo "Operation:   ${LOCK_OPERATION:-unknown}"
          echo "Created:     ${LOCK_CREATED:-unknown}"
          echo "=============================================="
          echo ""

          # Safety check: Only clear locks older than threshold
          if [ "$lock_age" -lt "$LOCK_AGE_THRESHOLD" ]; then
            echo "::error::=============================================="
            echo "::error::LOCK TOO RECENT - REFUSING TO CLEAR"
            echo "::error::=============================================="
            echo "::error::"
            echo "::error::Lock is only $lock_age minutes old (threshold: $LOCK_AGE_THRESHOLD minutes)"
            echo "::error::Another Terraform operation may be legitimately in progress."
            echo "::error::"
            echo "::error::Check for concurrent workflows:"
            echo "::error::  https://github.com/${GITHUB_REPO}/actions"
            echo "::error::"
            echo "::error::If you're certain the lock is stale, manually clear it:"
            echo "::error::  cd terraform && terraform force-unlock -force $lock_id"
            echo "::error::=============================================="
            return 1
          fi

          echo "Lock is $lock_age minutes old (>= $LOCK_AGE_THRESHOLD threshold) - safe to clear"
          echo ""

          # LAYER 1: Use terraform force-unlock
          echo "Attempting terraform force-unlock..."
          if terraform force-unlock -force "$lock_id" 2>&1; then
            echo "✓ terraform force-unlock succeeded"
          else
            echo "⚠️  terraform force-unlock command returned non-zero (may be expected)"
          fi

          # LAYER 2: Direct S3 deletion as fallback
          # With S3 native locking, the lock file is <state-key>.tflock
          echo ""
          echo "Verifying lock removal via S3..."
          sleep 2  # S3 eventual consistency

          local lock_file="${STATE_KEY}.tflock"

          if aws s3api head-object --bucket "$STATE_BUCKET" --key "$lock_file" 2>/dev/null; then
            echo "⚠️  Lock file still exists - attempting direct S3 deletion..."
            if aws s3api delete-object --bucket "$STATE_BUCKET" --key "$lock_file" 2>/dev/null; then
              echo "✓ Lock file deleted via S3 API"
            else
              echo "::error::Failed to delete lock file via S3 API"
              return 1
            fi
          else
            echo "✓ Lock file no longer exists in S3"
          fi

          # LAYER 3: Also check for legacy .lock.info file (migration safety)
          local legacy_lock_file="${STATE_KEY}.lock.info"
          if aws s3api head-object --bucket "$STATE_BUCKET" --key "$legacy_lock_file" 2>/dev/null; then
            echo "⚠️  Legacy lock file (.lock.info) detected - cleaning up..."
            aws s3api delete-object --bucket "$STATE_BUCKET" --key "$legacy_lock_file" 2>/dev/null || true
            echo "✓ Legacy lock file removed"
          fi

          echo ""
          echo "✓ Lock successfully cleared"
          return 0
        }

        #######################################################################
        # MAIN: Detection and clearing loop
        #######################################################################
        attempt=0
        while [ $attempt -lt "$MAX_RETRIES" ]; do
          attempt=$((attempt + 1))
          echo ""
          echo "=== Attempt $attempt of $MAX_RETRIES ==="
          echo ""

          # Run terraform plan with short lock timeout to detect locks
          echo "Running terraform plan with 10s lock timeout..."
          if LOCK_OUTPUT=$(terraform plan -input=false -lock-timeout=10s 2>&1); then
            echo "✓ Terraform plan succeeded - no lock detected"
            echo ""
            echo "State is accessible. Proceeding with operations."
            exit 0
          fi

          # Check if this is actually a lock error
          if ! echo "$LOCK_OUTPUT" | grep -qi "lock\|locked"; then
            echo "::error::Terraform plan failed for non-lock reason:"
            echo "$LOCK_OUTPUT"
            exit 1
          fi

          echo "Lock error detected. Analyzing..."
          echo ""

          # Parse lock information from error output
          parse_lock_info "$LOCK_OUTPUT"

          if [ -z "$LOCK_ID" ]; then
            echo "::error::Could not extract lock ID from error output"
            echo "::error::Raw error output:"
            echo "$LOCK_OUTPUT"
            echo ""
            echo "::error::Attempting direct S3 lock file detection..."

            # Fallback: Try to detect and remove lock file directly
            for lock_ext in ".tflock" ".lock.info"; do
              lock_file="${STATE_KEY}${lock_ext}"
              if aws s3api head-object --bucket "$STATE_BUCKET" --key "$lock_file" 2>/dev/null; then
                echo "Found lock file: $lock_file"

                # Download and display lock content
                if LOCK_CONTENT=$(aws s3 cp "s3://${STATE_BUCKET}/${lock_file}" - 2>/dev/null); then
                  echo "Lock content:"
                  echo "$LOCK_CONTENT" | jq '.' 2>/dev/null || echo "$LOCK_CONTENT"

                  # Extract lock ID from file content
                  LOCK_ID=$(echo "$LOCK_CONTENT" | jq -r '.ID // empty' 2>/dev/null || true)
                  if [ -n "$LOCK_ID" ]; then
                    # Extract creation time from lock file
                    LOCK_CREATED=$(echo "$LOCK_CONTENT" | jq -r '.Created // empty' 2>/dev/null | cut -d'.' -f1 | tr 'T' ' ' || true)
                    break
                  fi
                fi
              fi
            done

            if [ -z "$LOCK_ID" ]; then
              echo "::error::Could not determine lock ID from any source"
              exit 1
            fi
          fi

          # Calculate lock age
          LOCK_AGE=$(calculate_lock_age "$LOCK_CREATED")

          # Attempt to clear the lock
          if clear_lock "$LOCK_ID" "$LOCK_AGE"; then
            echo ""
            echo "Lock cleared. Waiting 5 seconds for S3 consistency..."
            sleep 5

            # Update outputs
            echo "lock_cleared=true" >> "$GITHUB_OUTPUT"
            echo "lock_id=$LOCK_ID" >> "$GITHUB_OUTPUT"

            # Continue to next iteration to verify lock is truly cleared
            continue
          else
            echo "::error::Failed to clear lock"
            exit 1
          fi
        done

        # If we exhausted all retries, the lock keeps coming back
        echo "::error::=============================================="
        echo "::error::LOCK PERSISTS AFTER $MAX_RETRIES ATTEMPTS"
        echo "::error::=============================================="
        echo "::error::"
        echo "::error::The lock keeps reappearing after being cleared."
        echo "::error::This indicates an active concurrent operation."
        echo "::error::"
        echo "::error::Check for running workflows:"
        echo "::error::  https://github.com/${GITHUB_REPO}/actions"
        echo "::error::"
        echo "::error::Or a long-running local terraform operation."
        echo "::error::=============================================="
        exit 1
