---
name: OCI Plex Proxy - Deploy/Recreate

on:
  # Monthly automated recreate for security updates
  # Runs at 4am UTC on the 1st of each month (~6-10 min downtime)
  schedule:
    - cron: '0 4 1 * *'

  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        type: choice
        options:
          - deploy
          - destroy
          - recreate
          - plan-only
        default: plan-only
      availability_domain:
        description: 'Availability Domain index (0=AD-1, 1=AD-2, 2=AD-3)'
        type: choice
        options:
          - '0'
          - '1'
          - '2'
        default: '0'
      enable_nginx_proxy:
        description: 'Enable nginx reverse proxy with Cloudflare (recommended)'
        type: boolean
        default: true

# Prevent concurrent operations (Terraform state lock protection)
concurrency:
  group: oci-plex-proxy
  cancel-in-progress: false

env:
  AWS_REGION: us-east-2
  TERRAFORM_VERSION: "1.14.0"
  WORKING_DIR: ./terraform/oci

jobs:
  terraform:
    name: ${{ inputs.action || 'recreate (scheduled)' }} OCI Plex Proxy
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # Resolve inputs with fallbacks for scheduled runs
    env:
      ACTION: ${{ inputs.action || 'recreate' }}
      AD_INDEX: ${{ inputs.availability_domain || '0' }}
      NGINX_ENABLED: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}

    steps:
      # =======================================================================
      # Workflow Metadata - Track trigger type and timing
      # =======================================================================
      - name: Workflow Metadata
        id: metadata
        run: |
          # Determine trigger type
          if [ "${{ github.event_name }}" = "schedule" ]; then
            TRIGGER_TYPE="scheduled"
            TRIGGER_ICON="ðŸ•"
            TRIGGER_DESC="Monthly security update (cron)"
          else
            TRIGGER_TYPE="manual"
            TRIGGER_ICON="ðŸ‘¤"
            TRIGGER_DESC="Manual trigger by @${{ github.actor }}"
          fi

          echo "trigger_type=$TRIGGER_TYPE" >> $GITHUB_OUTPUT
          echo "trigger_icon=$TRIGGER_ICON" >> $GITHUB_OUTPUT
          echo "trigger_desc=$TRIGGER_DESC" >> $GITHUB_OUTPUT
          echo "start_time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

          # Write header to summary
          echo "# OCI Plex Proxy Deployment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metadata | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Trigger | $TRIGGER_ICON $TRIGGER_DESC |" >> $GITHUB_STEP_SUMMARY
          echo "| Action | \`${{ inputs.action || 'recreate' }}\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Started | \`$(date -u '+%Y-%m-%d %H:%M:%S UTC')\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Run ID | [\`${{ github.run_id }}\`](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}) |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials (for S3 backend)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install WireGuard tools
        run: |
          # Required for terraform module to generate WireGuard keys via local-exec
          sudo apt-get update
          sudo apt-get install -y wireguard-tools

      - name: Pre-generate WireGuard keys
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          # Terraform terraform_data resource tracks state but local-exec only runs on create
          # After destroy+recreate, key files don't exist but state says they do
          # Pre-generate keys to ensure files exist for terraform plan
          KEY_DIR="modules/compute/.keys"
          mkdir -p "$KEY_DIR"
          if [ ! -f "$KEY_DIR/plex-proxy-private.key" ]; then
            echo "Generating WireGuard keys..."
            wg genkey > "$KEY_DIR/plex-proxy-private.key"
            # Use shell redirection instead of pipe to avoid exposing key in debug logs
            wg pubkey < "$KEY_DIR/plex-proxy-private.key" > "$KEY_DIR/plex-proxy-public.key"
            echo "Keys generated successfully"
          else
            echo "WireGuard keys already exist"
          fi

      - name: Initialize Terraform
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init

      - name: Clear stale Terraform locks
        working-directory: ${{ env.WORKING_DIR }}
        continue-on-error: true
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          # Security: Restrict SSH and WireGuard to home IP
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          # Nginx reverse proxy with Cloudflare
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
          TF_VAR_nginx_backend_url: ${{ secrets.NGINX_BACKEND_URL }}
          TF_VAR_plex_loadbalancer_ip: ${{ secrets.PLEX_LOADBALANCER_IP }}
        run: |
          echo "Checking for stale Terraform state locks..."
          if ! LOCK_OUTPUT=$(terraform plan -input=false -lock-timeout=1s 2>&1); then
            LOCK_ID=$(echo "$LOCK_OUTPUT" | grep -oP 'ID:\s*\K[a-f0-9-]{36}' | head -1)
            if [ -n "$LOCK_ID" ]; then
              echo "Found stale lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          fi

      # =======================================================================
      # RECREATE: First destroy existing resources (also runs on schedule)
      # =======================================================================
      - name: Terraform Destroy (recreate step 1)
        if: (inputs.action || 'recreate') == 'recreate'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
          TF_VAR_nginx_backend_url: ${{ secrets.NGINX_BACKEND_URL }}
          TF_VAR_plex_loadbalancer_ip: ${{ secrets.PLEX_LOADBALANCER_IP }}
        run: |
          # SECURITY: Ensure temp file cleanup even on failure
          cleanup() { rm -f /tmp/tfdestroy.txt; }
          trap cleanup EXIT

          echo "::group::Destroying existing resources"
          # SECURITY: Suppress detailed destroy output (contains user_data with secrets)
          terraform destroy -auto-approve -input=false > /tmp/tfdestroy.txt 2>&1
          DESTROY_EXIT=$?
          # Show only resource status (exclude any lines with sensitive patterns)
          grep -E '^(Destroy complete|Error:|Warning:|module\.[^:]+: (Destroying|Destruction complete))' /tmp/tfdestroy.txt | grep -v -E '(user_data|base64|PRIVATE KEY)' | head -30 || true
          if [ $DESTROY_EXIT -ne 0 ]; then
            echo "Destroy failed or nothing to destroy"
          fi
          echo "::endgroup::"

      - name: Terraform Plan
        if: (inputs.action || 'recreate') != 'destroy'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
          TF_VAR_nginx_backend_url: ${{ secrets.NGINX_BACKEND_URL }}
          TF_VAR_plex_loadbalancer_ip: ${{ secrets.PLEX_LOADBALANCER_IP }}
        run: |
          # SECURITY: Ensure temp file cleanup even on failure
          cleanup() { rm -f /tmp/tfplan.txt; }
          trap cleanup EXIT

          echo "::group::Terraform Plan"
          # SECURITY: Suppress detailed plan output to prevent secret leakage
          # user_data contains base64-encoded cloud-init with WireGuard/TLS private keys
          # Save full plan to file, show only summary in logs
          terraform plan -input=false -out=tfplan > /tmp/tfplan.txt 2>&1
          PLAN_EXIT=$?
          # Show only high-level summary (exclude any lines with sensitive patterns)
          grep -E '^(Plan:|No changes|Error:|Warning:|Terraform will perform)' /tmp/tfplan.txt | grep -v -E '(user_data|base64|PRIVATE KEY)' | head -20 || true
          echo "Plan saved to tfplan file"
          echo "::endgroup::"
          exit $PLAN_EXIT

      - name: Terraform Plan Destroy
        if: (inputs.action || 'recreate') == 'destroy'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
          TF_VAR_nginx_backend_url: ${{ secrets.NGINX_BACKEND_URL }}
          TF_VAR_plex_loadbalancer_ip: ${{ secrets.PLEX_LOADBALANCER_IP }}
        run: |
          # SECURITY: Ensure temp file cleanup even on failure
          cleanup() { rm -f /tmp/tfplan.txt; }
          trap cleanup EXIT

          echo "::group::Terraform Plan Destroy"
          # SECURITY: Suppress detailed plan output (same as plan step)
          terraform plan -destroy -input=false -out=tfplan > /tmp/tfplan.txt 2>&1
          PLAN_EXIT=$?
          grep -E '^(Plan:|No changes|Error:|Warning:|Terraform will perform)' /tmp/tfplan.txt | grep -v -E '(user_data|base64|PRIVATE KEY)' | head -20 || true
          echo "::endgroup::"
          exit $PLAN_EXIT

      - name: Terraform Apply
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'destroy' || (inputs.action || 'recreate') == 'recreate'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
          TF_VAR_nginx_backend_url: ${{ secrets.NGINX_BACKEND_URL }}
          TF_VAR_plex_loadbalancer_ip: ${{ secrets.PLEX_LOADBALANCER_IP }}
        run: |
          # SECURITY: Ensure temp file cleanup even on failure
          cleanup() { rm -f /tmp/tfapply.txt; }
          trap cleanup EXIT

          echo "::group::Terraform Apply"
          # SECURITY: Suppress detailed apply output (contains user_data with secrets)
          terraform apply -input=false tfplan > /tmp/tfapply.txt 2>&1
          APPLY_EXIT=$?
          # Show only resource status (exclude any lines with sensitive patterns)
          grep -E '^(Apply complete|Error:|Warning:|module\.[^:]+: (Creating|Creation complete|Destroying|Destruction complete))' /tmp/tfapply.txt | grep -v -E '(user_data|base64|PRIVATE KEY)' | head -30 || true
          echo "::endgroup::"
          exit $APPLY_EXIT

      - name: Get Outputs
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate'
        id: outputs
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
          TF_VAR_nginx_backend_url: ${{ secrets.NGINX_BACKEND_URL }}
          TF_VAR_plex_loadbalancer_ip: ${{ secrets.PLEX_LOADBALANCER_IP }}
        run: |
          echo "::group::Deployment Outputs"

          PUBLIC_IP=$(terraform output -raw plex_proxy_public_ip 2>/dev/null || echo "N/A")
          WG_ENDPOINT=$(terraform output -raw plex_proxy_wireguard_endpoint 2>/dev/null || echo "N/A")
          VPS_WG_PUB=$(terraform output -raw vps_wireguard_public_key 2>/dev/null || echo "N/A")

          # Export for subsequent steps
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
          echo "wg_endpoint=$WG_ENDPOINT" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      # =======================================================================
      # Health Checks - Verify VPS and connectivity
      # =======================================================================
      - name: Wait for VPS Boot
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate'
        run: |
          PUBLIC_IP="${{ steps.outputs.outputs.public_ip }}"
          echo "Waiting for VPS to boot and SSH to become available..."
          echo "Public IP: $PUBLIC_IP"

          # Wait up to 3 minutes for SSH port to be open
          MAX_ATTEMPTS=18
          ATTEMPT=0
          while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
            ATTEMPT=$((ATTEMPT + 1))
            if timeout 5 bash -c "cat < /dev/tcp/$PUBLIC_IP/22" 2>/dev/null; then
              echo "SSH port is open after $((ATTEMPT * 10)) seconds"
              break
            fi
            echo "Attempt $ATTEMPT/$MAX_ATTEMPTS: SSH not ready, waiting 10s..."
            sleep 10
          done

          if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
            echo "Warning: SSH port not responding after 3 minutes"
          fi

      - name: VPS Health Check
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate'
        id: health
        env:
          SSH_PRIVATE_KEY: ${{ secrets.OCI_SSH_PRIVATE_KEY }}
        run: |
          PUBLIC_IP="${{ steps.outputs.outputs.public_ip }}"

          # SECURITY: Ensure SSH key cleanup even on failure
          cleanup_ssh() { rm -f ~/.ssh/oci_key; }
          trap cleanup_ssh EXIT

          # Initialize health check results
          SSH_OK="false"
          CLOUD_INIT_OK="false"
          WG_OK="false"
          CLUSTER_OK="false"
          PLEX_OK="false"

          # Check if we have SSH key
          if [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "Warning: OCI_SSH_PRIVATE_KEY not set, skipping SSH-based health checks"
            echo "ssh_available=false" >> $GITHUB_OUTPUT
          else
            echo "ssh_available=true" >> $GITHUB_OUTPUT

            # Setup SSH key
            mkdir -p ~/.ssh
            echo "$SSH_PRIVATE_KEY" > ~/.ssh/oci_key
            chmod 600 ~/.ssh/oci_key

            # Wait for cloud-init to complete
            echo "Checking cloud-init status..."
            if ssh -i ~/.ssh/oci_key -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
               ubuntu@$PUBLIC_IP "sudo cloud-init status --wait" 2>/dev/null; then
              CLOUD_INIT_OK="true"
              SSH_OK="true"
              echo "Cloud-init completed successfully"
            else
              echo "Warning: Could not verify cloud-init status"
            fi

            # Check WireGuard tunnel
            echo "Checking WireGuard tunnel..."
            WG_STATUS=$(ssh -i ~/.ssh/oci_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
               ubuntu@$PUBLIC_IP "sudo wg show wg0 2>/dev/null | grep -c 'peer:'" 2>/dev/null || echo "0")
            if [ "$WG_STATUS" != "0" ]; then
              WG_OK="true"
              echo "WireGuard tunnel is up with $WG_STATUS peer(s)"
            else
              echo "Warning: WireGuard tunnel not established yet"
            fi

            # Test cluster connectivity via WireGuard
            WG_PEER_IP="${{ secrets.WG_K8S_PEER_IP }}"
            if [ -n "$WG_PEER_IP" ]; then
              echo "Testing cluster connectivity via WireGuard..."
              if ssh -i ~/.ssh/oci_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
                 ubuntu@$PUBLIC_IP "ping -c 1 -W 5 $WG_PEER_IP" 2>/dev/null | grep -q "1 received"; then
                CLUSTER_OK="true"
                echo "Cluster reachable via WireGuard tunnel"
              else
                echo "Warning: Cannot reach cluster via WireGuard"
              fi
            else
              echo "Note: WG_K8S_PEER_IP not configured, skipping cluster connectivity test"
            fi

            # Test Plex endpoint (using secret to avoid exposing URL)
            PLEX_ENDPOINT="${{ secrets.PLEX_INTERNAL_ENDPOINT }}"
            if [ -n "$PLEX_ENDPOINT" ]; then
              echo "Testing Plex accessibility..."
              if ssh -i ~/.ssh/oci_key -o StrictHostKeyChecking=no -o ConnectTimeout=10 \
                 ubuntu@$PUBLIC_IP "curl -s --connect-timeout 5 '$PLEX_ENDPOINT/identity'" 2>/dev/null | grep -q "MediaContainer"; then
                PLEX_OK="true"
                echo "Plex endpoint is accessible"
              else
                echo "Warning: Cannot reach Plex endpoint"
              fi
            else
              echo "Note: PLEX_INTERNAL_ENDPOINT not configured, skipping Plex test"
            fi
          fi

          # Export results
          echo "ssh_ok=$SSH_OK" >> $GITHUB_OUTPUT
          echo "cloud_init_ok=$CLOUD_INIT_OK" >> $GITHUB_OUTPUT
          echo "wg_ok=$WG_OK" >> $GITHUB_OUTPUT
          echo "cluster_ok=$CLUSTER_OK" >> $GITHUB_OUTPUT
          echo "plex_ok=$PLEX_OK" >> $GITHUB_OUTPUT

      # Cloudflare DNS Management - Update/Create A record for streaming.homelab0.org
      - name: Update Cloudflare DNS
        if: ((inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate') && (inputs.enable_nginx_proxy == true || inputs.enable_nginx_proxy == '')
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          DNS_NAME: "streaming.homelab0.org"
        run: |
          echo "::group::Cloudflare DNS Update"
          PUBLIC_IP="${{ steps.outputs.outputs.public_ip }}"

          if [ "$PUBLIC_IP" = "N/A" ] || [ -z "$PUBLIC_IP" ]; then
            echo "Error: Could not get public IP from Terraform outputs"
            exit 1
          fi

          # Validate IP format with octet range check (defense-in-depth)
          # Each octet must be 0-255
          validate_ip() {
            local ip=$1
            local IFS='.'
            read -ra octets <<< "$ip"
            [ ${#octets[@]} -ne 4 ] && return 1
            for octet in "${octets[@]}"; do
              [[ ! "$octet" =~ ^[0-9]+$ ]] && return 1
              # Only need to check > 255; negative numbers already excluded by regex
              [ "$octet" -gt 255 ] && return 1
            done
            return 0
          }
          if ! validate_ip "$PUBLIC_IP"; then
            echo "Error: Invalid IP format: $PUBLIC_IP"
            exit 1
          fi

          echo "Updating Cloudflare DNS: $DNS_NAME -> $PUBLIC_IP (proxied)"

          # Check if record exists
          EXISTING_RECORD=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?type=A&name=$DNS_NAME" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")

          RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // empty')
          CURRENT_IP=$(echo "$EXISTING_RECORD" | jq -r '.result[0].content // empty')

          if [ -n "$RECORD_ID" ]; then
            # Update existing record
            echo "Found existing record (ID: $RECORD_ID, IP: $CURRENT_IP)"
            if [ "$CURRENT_IP" = "$PUBLIC_IP" ]; then
              echo "DNS record already points to $PUBLIC_IP, no update needed"
            else
              echo "Updating DNS record to point to $PUBLIC_IP"
              RESULT=$(curl -s -X PUT \
                "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CF_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"A\",\"name\":\"$DNS_NAME\",\"content\":\"$PUBLIC_IP\",\"ttl\":1,\"proxied\":true}")

              if echo "$RESULT" | jq -e '.success' > /dev/null; then
                echo "DNS record updated successfully"
              else
                echo "Failed to update DNS record:"
                echo "$RESULT" | jq .
                exit 1
              fi
            fi
          else
            # Create new record
            echo "No existing record found, creating new A record"
            RESULT=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$DNS_NAME\",\"content\":\"$PUBLIC_IP\",\"ttl\":1,\"proxied\":true}")

            if echo "$RESULT" | jq -e '.success' > /dev/null; then
              echo "DNS record created successfully"
            else
              echo "Failed to create DNS record:"
              echo "$RESULT" | jq .
              exit 1
            fi
          fi
          echo "::endgroup::"

      # =======================================================================
      # Deployment Summary - Comprehensive status report
      # =======================================================================
      - name: Deployment Summary
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate'
        env:
          ENABLE_NGINX: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
        run: |
          PUBLIC_IP="${{ steps.outputs.outputs.public_ip }}"
          START_TIME="${{ steps.metadata.outputs.start_time }}"
          END_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)

          # Calculate duration
          START_SEC=$(date -d "$START_TIME" +%s 2>/dev/null || echo "0")
          END_SEC=$(date -d "$END_TIME" +%s 2>/dev/null || echo "0")
          if [ "$START_SEC" != "0" ] && [ "$END_SEC" != "0" ]; then
            DURATION=$((END_SEC - START_SEC))
            DURATION_MIN=$((DURATION / 60))
            DURATION_SEC=$((DURATION % 60))
            DURATION_STR="${DURATION_MIN}m ${DURATION_SEC}s"
          else
            DURATION_STR="N/A"
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## Deployment Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Public IP | \`$PUBLIC_IP\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Nginx Proxy | $ENABLE_NGINX |" >> $GITHUB_STEP_SUMMARY
          echo "| Duration | $DURATION_STR |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Health check results
          echo "## Health Checks" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Build health check table
          SSH_AVAILABLE="${{ steps.health.outputs.ssh_available }}"
          if [ "$SSH_AVAILABLE" = "true" ]; then
            SSH_OK="${{ steps.health.outputs.ssh_ok }}"
            CLOUD_INIT_OK="${{ steps.health.outputs.cloud_init_ok }}"
            WG_OK="${{ steps.health.outputs.wg_ok }}"
            CLUSTER_OK="${{ steps.health.outputs.cluster_ok }}"
            PLEX_OK="${{ steps.health.outputs.plex_ok }}"

            echo "| Check | Status |" >> $GITHUB_STEP_SUMMARY
            echo "|-------|--------|" >> $GITHUB_STEP_SUMMARY
            echo "| SSH Access | $([ \"$SSH_OK\" = \"true\" ] && echo 'âœ… Pass' || echo 'âŒ Fail') |" >> $GITHUB_STEP_SUMMARY
            echo "| Cloud-init | $([ \"$CLOUD_INIT_OK\" = \"true\" ] && echo 'âœ… Complete' || echo 'âš ï¸ Pending') |" >> $GITHUB_STEP_SUMMARY
            echo "| WireGuard Tunnel | $([ \"$WG_OK\" = \"true\" ] && echo 'âœ… Established' || echo 'âš ï¸ Not Ready') |" >> $GITHUB_STEP_SUMMARY
            echo "| Cluster Connectivity | $([ \"$CLUSTER_OK\" = \"true\" ] && echo 'âœ… Reachable' || echo 'âš ï¸ Unreachable') |" >> $GITHUB_STEP_SUMMARY
            echo "| Plex Endpoint | $([ \"$PLEX_OK\" = \"true\" ] && echo 'âœ… Accessible' || echo 'âš ï¸ Not Tested') |" >> $GITHUB_STEP_SUMMARY
          else
            echo "> âš ï¸ SSH key not configured. Add \`OCI_SSH_PRIVATE_KEY\` secret for health checks." >> $GITHUB_STEP_SUMMARY
            echo ">" >> $GITHUB_STEP_SUMMARY
            echo "> Optionally add \`PLEX_INTERNAL_ENDPOINT\` secret for Plex accessibility testing." >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY

          # Access URLs section
          if [ "$ENABLE_NGINX" = "true" ]; then
            echo "## Access" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|-----|" >> $GITHUB_STEP_SUMMARY
            echo "| Plex (Cloudflare) | \`https://streaming.homelab0.org\` |" >> $GITHUB_STEP_SUMMARY
            echo "| SSH | \`ssh ubuntu@$PUBLIC_IP\` |" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Security" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Port 443: Cloudflare IPs only" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… Port 32400: Closed (traffic via nginx)" >> $GITHUB_STEP_SUMMARY
            echo "- âœ… VPS IP hidden behind Cloudflare proxy" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Access" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Service | URL |" >> $GITHUB_STEP_SUMMARY
            echo "|---------|-----|" >> $GITHUB_STEP_SUMMARY
            echo "| Plex (Direct) | \`http://$PUBLIC_IP:32400\` |" >> $GITHUB_STEP_SUMMARY
            echo "| SSH | \`ssh ubuntu@$PUBLIC_IP\` |" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Destroy Summary
        if: (inputs.action || 'recreate') == 'destroy'
        run: |
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## OCI Plex Proxy Destroyed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The OCI Plex Proxy VM has been destroyed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To redeploy, run this workflow with action: **deploy**" >> $GITHUB_STEP_SUMMARY
