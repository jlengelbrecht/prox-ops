---
name: OCI Plex Proxy - Deploy/Recreate

on:
  # Monthly automated recreate for security updates
  # Runs at 4am UTC on the 1st of each month (~6-10 min downtime)
  schedule:
    - cron: '0 4 1 * *'

  workflow_dispatch:
    inputs:
      action:
        description: 'Action to perform'
        type: choice
        options:
          - deploy
          - destroy
          - recreate
          - plan-only
        default: plan-only
      availability_domain:
        description: 'Availability Domain index (0=AD-1, 1=AD-2, 2=AD-3)'
        type: choice
        options:
          - '0'
          - '1'
          - '2'
        default: '0'
      enable_nginx_proxy:
        description: 'Enable nginx reverse proxy with Cloudflare (recommended)'
        type: boolean
        default: true

# Prevent concurrent operations (Terraform state lock protection)
concurrency:
  group: oci-plex-proxy
  cancel-in-progress: false

env:
  AWS_REGION: us-east-2
  TERRAFORM_VERSION: "1.14.0"
  WORKING_DIR: ./terraform/oci

jobs:
  terraform:
    name: ${{ inputs.action || 'recreate (scheduled)' }} OCI Plex Proxy
    runs-on: ubuntu-latest
    timeout-minutes: 30

    # Resolve inputs with fallbacks for scheduled runs
    env:
      ACTION: ${{ inputs.action || 'recreate' }}
      AD_INDEX: ${{ inputs.availability_domain || '0' }}
      NGINX_ENABLED: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Configure AWS credentials (for S3 backend)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Install WireGuard tools
        run: |
          # Required for terraform module to generate WireGuard keys via local-exec
          sudo apt-get update
          sudo apt-get install -y wireguard-tools

      - name: Pre-generate WireGuard keys
        working-directory: ${{ env.WORKING_DIR }}
        run: |
          # Terraform terraform_data resource tracks state but local-exec only runs on create
          # After destroy+recreate, key files don't exist but state says they do
          # Pre-generate keys to ensure files exist for terraform plan
          KEY_DIR="modules/compute/.keys"
          mkdir -p "$KEY_DIR"
          if [ ! -f "$KEY_DIR/plex-proxy-private.key" ]; then
            echo "Generating WireGuard keys..."
            wg genkey > "$KEY_DIR/plex-proxy-private.key"
            cat "$KEY_DIR/plex-proxy-private.key" | wg pubkey > "$KEY_DIR/plex-proxy-public.key"
            echo "Keys generated successfully"
          else
            echo "WireGuard keys already exist"
          fi

      - name: Initialize Terraform
        working-directory: ${{ env.WORKING_DIR }}
        run: terraform init

      - name: Clear stale Terraform locks
        working-directory: ${{ env.WORKING_DIR }}
        continue-on-error: true
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          # Security: Restrict SSH and WireGuard to home IP
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          # Nginx reverse proxy with Cloudflare
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
        run: |
          echo "Checking for stale Terraform state locks..."
          if ! LOCK_OUTPUT=$(terraform plan -input=false -lock-timeout=1s 2>&1); then
            LOCK_ID=$(echo "$LOCK_OUTPUT" | grep -oP 'ID:\s*\K[a-f0-9-]{36}' | head -1)
            if [ -n "$LOCK_ID" ]; then
              echo "Found stale lock: $LOCK_ID"
              terraform force-unlock -force "$LOCK_ID" || true
            fi
          fi

      # RECREATE: First destroy existing resources (also runs on schedule)
      - name: Terraform Destroy (recreate step 1)
        if: (inputs.action || 'recreate') == 'recreate'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
        run: |
          echo "::group::Destroying existing resources"
          terraform destroy -auto-approve -input=false || echo "Nothing to destroy"
          echo "::endgroup::"

      - name: Terraform Plan
        if: (inputs.action || 'recreate') != 'destroy'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
        run: |
          echo "::group::Terraform Plan"
          # SECURITY: Suppress detailed plan output to prevent secret leakage
          # user_data contains base64-encoded cloud-init with WireGuard/TLS private keys
          # Save full plan to file, show only summary in logs
          terraform plan -input=false -out=tfplan > /tmp/tfplan.txt 2>&1
          PLAN_EXIT=$?
          # Show only summary lines (no resource details with secrets)
          grep -E '^(Plan:|No changes|Error:|Warning:|module\.)' /tmp/tfplan.txt | head -20 || true
          echo "---"
          tail -5 /tmp/tfplan.txt || true
          echo "Plan saved to tfplan file"
          exit $PLAN_EXIT
          echo "::endgroup::"

      - name: Terraform Plan Destroy
        if: (inputs.action || 'recreate') == 'destroy'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
        run: |
          echo "::group::Terraform Plan Destroy"
          # SECURITY: Suppress detailed plan output (same as plan step)
          terraform plan -destroy -input=false -out=tfplan > /tmp/tfplan.txt 2>&1
          PLAN_EXIT=$?
          grep -E '^(Plan:|No changes|Error:|Warning:|module\.)' /tmp/tfplan.txt | head -20 || true
          echo "---"
          tail -5 /tmp/tfplan.txt || true
          exit $PLAN_EXIT
          echo "::endgroup::"

      - name: Terraform Apply
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'destroy' || (inputs.action || 'recreate') == 'recreate'
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
        run: |
          echo "::group::Terraform Apply"
          # SECURITY: Suppress detailed apply output (contains user_data with secrets)
          terraform apply -input=false tfplan > /tmp/tfapply.txt 2>&1
          APPLY_EXIT=$?
          # Show only summary (resource creation status, no attribute values)
          grep -E '^(Apply complete|Error:|Warning:|module\.[^:]+: (Creating|Creation complete|Destroying|Destruction complete))' /tmp/tfapply.txt | head -30 || true
          echo "---"
          tail -5 /tmp/tfapply.txt || true
          exit $APPLY_EXIT
          echo "::endgroup::"

      - name: Get Outputs
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate'
        id: outputs
        working-directory: ${{ env.WORKING_DIR }}
        env:
          TF_VAR_oci_tenancy_ocid: ${{ secrets.OCI_TENANCY_OCID }}
          TF_VAR_oci_user_ocid: ${{ secrets.OCI_USER_OCID }}
          TF_VAR_oci_fingerprint: ${{ secrets.OCI_FINGERPRINT }}
          TF_VAR_oci_private_key: ${{ secrets.OCI_PRIVATE_KEY }}
          TF_VAR_compartment_id: ${{ secrets.OCI_COMPARTMENT_ID }}
          TF_VAR_ssh_public_key: ${{ secrets.OCI_SSH_PUBLIC_KEY }}
          TF_VAR_k8s_wg_public_key: ${{ secrets.K8S_WG_PUBLIC_KEY }}
          TF_VAR_availability_domain_index: ${{ inputs.availability_domain || '0' }}
          TF_VAR_ssh_allowed_cidrs: ${{ secrets.OCI_SSH_ALLOWED_CIDRS }}
          TF_VAR_wg_peer_allowed_cidrs: ${{ secrets.OCI_WG_PEER_ALLOWED_CIDRS }}
          TF_VAR_enable_nginx_proxy: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
          TF_VAR_nginx_server_name: "streaming.homelab0.org"
          TF_VAR_nginx_origin_cert: ${{ secrets.CLOUDFLARE_ORIGIN_CERT }}
          TF_VAR_nginx_origin_key: ${{ secrets.CLOUDFLARE_ORIGIN_KEY }}
        run: |
          echo "::group::Deployment Outputs"

          PUBLIC_IP=$(terraform output -raw plex_proxy_public_ip 2>/dev/null || echo "N/A")
          WG_ENDPOINT=$(terraform output -raw plex_proxy_wireguard_endpoint 2>/dev/null || echo "N/A")
          VPS_WG_PUB=$(terraform output -raw vps_wireguard_public_key 2>/dev/null || echo "N/A")

          # Export for Cloudflare DNS step
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT

          echo "::endgroup::"

      # Cloudflare DNS Management - Update/Create A record for streaming.homelab0.org
      - name: Update Cloudflare DNS
        if: ((inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate') && (inputs.enable_nginx_proxy == true || inputs.enable_nginx_proxy == '')
        env:
          CF_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CF_ZONE_ID: ${{ secrets.CLOUDFLARE_ZONE_ID }}
          DNS_NAME: "streaming.homelab0.org"
        run: |
          echo "::group::Cloudflare DNS Update"
          PUBLIC_IP="${{ steps.outputs.outputs.public_ip }}"

          if [ "$PUBLIC_IP" = "N/A" ] || [ -z "$PUBLIC_IP" ]; then
            echo "Error: Could not get public IP from Terraform outputs"
            exit 1
          fi

          # Validate IP format with octet range check (defense-in-depth)
          # Each octet must be 0-255
          validate_ip() {
            local ip=$1
            local IFS='.'
            read -ra octets <<< "$ip"
            [ ${#octets[@]} -ne 4 ] && return 1
            for octet in "${octets[@]}"; do
              [[ ! "$octet" =~ ^[0-9]+$ ]] && return 1
              # FIX: Use proper grouping for OR condition (operator precedence fix)
              [ "$octet" -lt 0 -o "$octet" -gt 255 ] && return 1
            done
            return 0
          }
          if ! validate_ip "$PUBLIC_IP"; then
            echo "Error: Invalid IP format: $PUBLIC_IP"
            exit 1
          fi

          echo "Updating Cloudflare DNS: $DNS_NAME -> $PUBLIC_IP (proxied)"

          # Check if record exists
          EXISTING_RECORD=$(curl -s -X GET \
            "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records?type=A&name=$DNS_NAME" \
            -H "Authorization: Bearer $CF_API_TOKEN" \
            -H "Content-Type: application/json")

          RECORD_ID=$(echo "$EXISTING_RECORD" | jq -r '.result[0].id // empty')
          CURRENT_IP=$(echo "$EXISTING_RECORD" | jq -r '.result[0].content // empty')

          if [ -n "$RECORD_ID" ]; then
            # Update existing record
            echo "Found existing record (ID: $RECORD_ID, IP: $CURRENT_IP)"
            if [ "$CURRENT_IP" = "$PUBLIC_IP" ]; then
              echo "DNS record already points to $PUBLIC_IP, no update needed"
            else
              echo "Updating DNS record to point to $PUBLIC_IP"
              RESULT=$(curl -s -X PUT \
                "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records/$RECORD_ID" \
                -H "Authorization: Bearer $CF_API_TOKEN" \
                -H "Content-Type: application/json" \
                --data "{\"type\":\"A\",\"name\":\"$DNS_NAME\",\"content\":\"$PUBLIC_IP\",\"ttl\":1,\"proxied\":true}")

              if echo "$RESULT" | jq -e '.success' > /dev/null; then
                echo "DNS record updated successfully"
              else
                echo "Failed to update DNS record:"
                echo "$RESULT" | jq .
                exit 1
              fi
            fi
          else
            # Create new record
            echo "No existing record found, creating new A record"
            RESULT=$(curl -s -X POST \
              "https://api.cloudflare.com/client/v4/zones/$CF_ZONE_ID/dns_records" \
              -H "Authorization: Bearer $CF_API_TOKEN" \
              -H "Content-Type: application/json" \
              --data "{\"type\":\"A\",\"name\":\"$DNS_NAME\",\"content\":\"$PUBLIC_IP\",\"ttl\":1,\"proxied\":true}")

            if echo "$RESULT" | jq -e '.success' > /dev/null; then
              echo "DNS record created successfully"
            else
              echo "Failed to create DNS record:"
              echo "$RESULT" | jq .
              exit 1
            fi
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Cloudflare DNS" >> $GITHUB_STEP_SUMMARY
          echo "| Setting | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|---------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Domain | \`$DNS_NAME\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Points to | \`$PUBLIC_IP\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Proxy | Enabled (orange cloud) |" >> $GITHUB_STEP_SUMMARY
          echo "::endgroup::"

      - name: Deployment Summary
        if: (inputs.action || 'recreate') == 'deploy' || (inputs.action || 'recreate') == 'recreate'
        env:
          ENABLE_NGINX: ${{ inputs.enable_nginx_proxy == '' && 'true' || inputs.enable_nginx_proxy }}
        run: |
          PUBLIC_IP="${{ steps.outputs.outputs.public_ip }}"

          echo "## Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Resource | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| Public IP | \`$PUBLIC_IP\` |" >> $GITHUB_STEP_SUMMARY
          echo "| Nginx Proxy | $ENABLE_NGINX |" >> $GITHUB_STEP_SUMMARY

          if [ "$ENABLE_NGINX" = "true" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Access URLs" >> $GITHUB_STEP_SUMMARY
            echo "- **Plex via Cloudflare**: \`https://streaming.homelab0.org\`" >> $GITHUB_STEP_SUMMARY
            echo "- **SSH**: \`ssh ubuntu@$PUBLIC_IP\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Security" >> $GITHUB_STEP_SUMMARY
            echo "- Port 443: Cloudflare IPs only" >> $GITHUB_STEP_SUMMARY
            echo "- Port 32400: Closed (traffic via nginx)" >> $GITHUB_STEP_SUMMARY
            echo "- VPS IP hidden behind Cloudflare proxy" >> $GITHUB_STEP_SUMMARY
          else
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### Access URLs" >> $GITHUB_STEP_SUMMARY
            echo "- **Plex direct**: \`http://$PUBLIC_IP:32400\`" >> $GITHUB_STEP_SUMMARY
            echo "- **SSH**: \`ssh ubuntu@$PUBLIC_IP\`" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify WireGuard tunnel is established" >> $GITHUB_STEP_SUMMARY
          echo "2. Test Plex connectivity" >> $GITHUB_STEP_SUMMARY
          if [ "$ENABLE_NGINX" = "true" ]; then
            echo "3. Verify Cloudflare proxy is working" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Destroy Summary
        if: (inputs.action || 'recreate') == 'destroy'
        run: |
          echo "## OCI Plex Proxy Destroyed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The OCI Plex Proxy VM has been destroyed." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "To redeploy, run this workflow with action: **deploy**" >> $GITHUB_STEP_SUMMARY
