---
name: "Security Gate"

on:
  pull_request:
    branches: ["main"]
  push:
    branches: ["main"]
  workflow_dispatch:
    inputs:
      scan_type:
        description: "Type of scan to run"
        required: true
        default: "protect"
        type: choice
        options:
          - protect
          - detect

concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.ref }}
  cancel-in-progress: true

env:
  # renovate: datasource=github-releases depName=gitleaks/gitleaks
  GITLEAKS_VERSION: "8.21.2"
  # renovate: datasource=pypi depName=ensure-sops
  ENSURE_SOPS_VERSION: "0.1.2"

jobs:
  # =============================================================================
  # Job 1: Gitleaks Secret Scanning
  # =============================================================================
  gitleaks:
    name: Gitleaks Secret Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      security-events: write
    outputs:
      leaks_found: ${{ steps.gitleaks-pr.outputs.LEAKS_FOUND || steps.gitleaks-push.outputs.LEAKS_FOUND || steps.gitleaks-manual.outputs.LEAKS_FOUND }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        run: |
          # Fetch SHA256 checksum dynamically from official release
          EXPECTED_SHA=$(curl -sL https://github.com/gitleaks/gitleaks/releases/download/v${{ env.GITLEAKS_VERSION }}/gitleaks_${{ env.GITLEAKS_VERSION }}_checksums.txt | grep linux_x64 | awk '{print $1}')
          if [ -z "$EXPECTED_SHA" ]; then
            echo "::error::Failed to fetch checksum for Gitleaks v${{ env.GITLEAKS_VERSION }}"
            exit 1
          fi
          curl -sSfL -o gitleaks.tar.gz https://github.com/gitleaks/gitleaks/releases/download/v${{ env.GITLEAKS_VERSION }}/gitleaks_${{ env.GITLEAKS_VERSION }}_linux_x64.tar.gz
          echo "$EXPECTED_SHA  gitleaks.tar.gz" | sha256sum -c -
          tar -xzf gitleaks.tar.gz
          sudo mv gitleaks /usr/local/bin/
          rm gitleaks.tar.gz
          gitleaks version

      - name: Run Gitleaks (PR - Scan commits in PR)
        if: github.event_name == 'pull_request'
        id: gitleaks-pr
        run: |
          # Scan only the commits in the PR
          gitleaks detect \
            --config .gitleaks.toml \
            --log-opts "${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }}" \
            --report-format sarif \
            --report-path gitleaks-report.sarif \
            --verbose \
            --exit-code 1 || echo "LEAKS_FOUND=true" >> $GITHUB_OUTPUT

      - name: Run Gitleaks (Push - Scan new commits)
        if: github.event_name == 'push'
        id: gitleaks-push
        run: |
          BEFORE="${{ github.event.before }}"
          # Handle force-push or new branch (before is all zeros)
          if [[ "$BEFORE" == "0000000000000000000000000000000000000000" ]]; then
            echo "Force push or new branch detected, scanning full repository"
            gitleaks detect \
              --config .gitleaks.toml \
              --report-format sarif \
              --report-path gitleaks-report.sarif \
              --verbose \
              --exit-code 1 || echo "LEAKS_FOUND=true" >> $GITHUB_OUTPUT
          else
            # Scan the pushed commits
            gitleaks detect \
              --config .gitleaks.toml \
              --log-opts "$BEFORE..${{ github.sha }}" \
              --report-format sarif \
              --report-path gitleaks-report.sarif \
              --verbose \
              --exit-code 1 || echo "LEAKS_FOUND=true" >> $GITHUB_OUTPUT
          fi

      - name: Run Gitleaks (Manual - Full repo scan)
        if: github.event_name == 'workflow_dispatch'
        id: gitleaks-manual
        run: |
          if [ "${{ github.event.inputs.scan_type }}" = "detect" ]; then
            # Full historical scan
            gitleaks detect \
              --config .gitleaks.toml \
              --report-format sarif \
              --report-path gitleaks-report.sarif \
              --verbose \
              --exit-code 1 || echo "LEAKS_FOUND=true" >> $GITHUB_OUTPUT
          else
            # Protect mode - scan only uncommitted changes
            gitleaks protect \
              --config .gitleaks.toml \
              --report-format sarif \
              --report-path gitleaks-report.sarif \
              --verbose \
              --exit-code 1 || echo "LEAKS_FOUND=true" >> $GITHUB_OUTPUT
          fi

      - name: Upload SARIF Report
        if: always()
        uses: github/codeql-action/upload-sarif@5d4e8d1aca955e8d8589aabd499c5cae939e33c7 # v4.31.9
        with:
          sarif_file: gitleaks-report.sarif
          category: gitleaks
        continue-on-error: true

      - name: Generate GitHub App Token
        if: github.event_name == 'pull_request'
        id: generate-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.BOT_APP_ID }}
          private-key: ${{ secrets.BOT_APP_PRIVATE_KEY }}

      - name: Comment on PR (Gitleaks success)
        if: github.event_name == 'pull_request' && steps.gitleaks-pr.outputs.LEAKS_FOUND != 'true'
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2.8.2
        with:
          repo-token: ${{ steps.generate-token.outputs.token }}
          message-id: "gitleaks-scan"
          message: |
            ## :white_check_mark: Gitleaks Secret Scan Passed

            No secrets detected in this pull request.

            | Check | Status |
            |-------|--------|
            | Secret patterns | :white_check_mark: Clean |
            | Sensitive files | :white_check_mark: None detected |

      - name: Generate Gitleaks failure comment
        if: github.event_name == 'pull_request' && steps.gitleaks-pr.outputs.LEAKS_FOUND == 'true'
        id: gitleaks-failure-body
        run: |
          {
            echo 'COMMENT_BODY<<EOF'
            echo '## :x: Gitleaks Secret Scan Failed'
            echo ''
            echo 'Potential secrets were detected in this pull request.'
            echo ''

            # Validate SARIF structure before parsing
            if jq -e '.runs[0].results' gitleaks-report.sarif >/dev/null 2>&1; then
              echo '| Rule | File | Line | Description |'
              echo '|------|------|------|-------------|'
              jq -r '.runs[0].results[0:10][] | "| \(.ruleId) | `\(.locations[0].physicalLocation.artifactLocation.uri)` | \(.locations[0].physicalLocation.region.startLine) | \(.message.text | gsub("\n"; " ") | .[0:60]) |"' gitleaks-report.sarif 2>/dev/null || true
              COUNT=$(jq '.runs[0].results | length' gitleaks-report.sarif 2>/dev/null || echo "0")
              if [ "$COUNT" -gt 10 ]; then
                echo ""
                echo "*...and $((COUNT - 10)) more findings*"
              fi
            else
              echo '*Unable to parse SARIF report. Check workflow logs for details.*'
            fi

            echo ''
            echo '### Required Actions'
            echo ''
            echo '1. Remove any real secrets from the code'
            echo '2. If this is a false positive, add to allowlist in `.gitleaks.toml`'
            echo '3. If secrets were committed, rotate them immediately'
            echo ''
            echo '**This PR cannot be merged until all secrets are removed.**'
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Comment on PR (Gitleaks secrets found)
        if: github.event_name == 'pull_request' && steps.gitleaks-pr.outputs.LEAKS_FOUND == 'true'
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2.8.2
        with:
          repo-token: ${{ steps.generate-token.outputs.token }}
          message-id: "gitleaks-scan"
          message: ${{ steps.gitleaks-failure-body.outputs.COMMENT_BODY }}

      - name: Fail if secrets found
        if: |
          steps.gitleaks-pr.outputs.LEAKS_FOUND == 'true' ||
          steps.gitleaks-push.outputs.LEAKS_FOUND == 'true' ||
          steps.gitleaks-manual.outputs.LEAKS_FOUND == 'true'
        run: |
          echo "::error::Secrets detected! Review the Gitleaks report and remove any secrets before merging."
          exit 1

  # =============================================================================
  # Job 2: SOPS Encryption Validation
  # =============================================================================
  sops-validation:
    name: SOPS Encryption Check
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    outputs:
      sops_found: ${{ steps.find-sops.outputs.SOPS_FOUND }}
      sops_failed: ${{ steps.validate-sops.outputs.SOPS_FAILED }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
        with:
          python-version: "3.14"  # ensure-sops requires Python <3.11

      - name: Install ensure-sops
        run: |
          pip install ensure-sops==${{ env.ENSURE_SOPS_VERSION }}
          echo "ensure-sops version: $(pip show ensure-sops | grep Version)"

      - name: Find SOPS files in PR
        id: find-sops
        run: |
          # Get list of changed files based on event type
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            CHANGED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})
          elif [ "${{ github.event_name }}" = "push" ]; then
            BEFORE="${{ github.event.before }}"
            if [[ "$BEFORE" == "0000000000000000000000000000000000000000" ]]; then
              # New branch or force push - check all SOPS files
              CHANGED_FILES=$(find . -name "*.sops.yaml" -o -name "*.sops.yml" | sed 's|^\./||')
            else
              CHANGED_FILES=$(git diff --name-only "$BEFORE"..${{ github.sha }})
            fi
          else
            # Manual run - check all SOPS files
            CHANGED_FILES=$(find . -name "*.sops.yaml" -o -name "*.sops.yml" | sed 's|^\./||')
          fi

          # Filter for SOPS files only
          SOPS_FILES=$(echo "$CHANGED_FILES" | grep -E '\.sops\.(yaml|yml)$' || true)

          if [ -z "$SOPS_FILES" ]; then
            echo "No SOPS files found in changes"
            echo "SOPS_FOUND=false" >> $GITHUB_OUTPUT
            echo "SOPS_FILES=" >> $GITHUB_OUTPUT
          else
            echo "Found SOPS files:"
            echo "$SOPS_FILES"
            echo "SOPS_FOUND=true" >> $GITHUB_OUTPUT
            # Store files as newline-separated list
            {
              echo 'SOPS_FILES<<EOF'
              echo "$SOPS_FILES"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          fi

      - name: Validate SOPS encryption
        id: validate-sops
        if: steps.find-sops.outputs.SOPS_FOUND == 'true'
        run: |
          echo "Validating SOPS encryption for files:"
          echo "${{ steps.find-sops.outputs.SOPS_FILES }}"

          FAILED_FILES=""
          PASSED_FILES=""

          while IFS= read -r file; do
            if [ -z "$file" ]; then
              continue
            fi

            echo "Checking: $file"

            # Run ensure_sops and capture output
            if ensure_sops "$file" 2>&1; then
              echo "  PASS: $file is properly encrypted"
              PASSED_FILES="${PASSED_FILES}${file}
          "
            else
              echo "  FAIL: $file is NOT properly encrypted"
              FAILED_FILES="${FAILED_FILES}${file}
          "
            fi
          done <<< "${{ steps.find-sops.outputs.SOPS_FILES }}"

          if [ -n "$FAILED_FILES" ]; then
            echo "SOPS_FAILED=true" >> $GITHUB_OUTPUT
            {
              echo 'FAILED_FILES<<EOF'
              echo "$FAILED_FILES"
              echo 'EOF'
            } >> $GITHUB_OUTPUT
          else
            echo "SOPS_FAILED=false" >> $GITHUB_OUTPUT
          fi

          {
            echo 'PASSED_FILES<<EOF'
            echo "$PASSED_FILES"
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Generate GitHub App Token
        if: github.event_name == 'pull_request'
        id: generate-token
        uses: actions/create-github-app-token@29824e69f54612133e76f7eaac726eef6c875baf # v2.2.1
        with:
          app-id: ${{ secrets.BOT_APP_ID }}
          private-key: ${{ secrets.BOT_APP_PRIVATE_KEY }}

      - name: Comment on PR (No SOPS files)
        if: github.event_name == 'pull_request' && steps.find-sops.outputs.SOPS_FOUND != 'true'
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2.8.2
        with:
          repo-token: ${{ steps.generate-token.outputs.token }}
          message-id: "sops-validation"
          message: |
            ## :information_source: SOPS Encryption Check

            No SOPS files detected in this pull request.

            | Check | Status |
            |-------|--------|
            | SOPS files in PR | :white_check_mark: None detected |

            *No encryption validation required for this PR.*

      - name: Comment on PR (SOPS validation passed)
        if: github.event_name == 'pull_request' && steps.find-sops.outputs.SOPS_FOUND == 'true' && steps.validate-sops.outputs.SOPS_FAILED != 'true'
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2.8.2
        with:
          repo-token: ${{ steps.generate-token.outputs.token }}
          message-id: "sops-validation"
          message: |
            ## :white_check_mark: SOPS Encryption Check Passed

            All SOPS files in this pull request are properly encrypted.

            | Check | Status |
            |-------|--------|
            | SOPS files detected | :white_check_mark: Yes |
            | Encryption validated | :white_check_mark: All files encrypted |
            | `sops:` metadata | :white_check_mark: Present |
            | `ENC[...]` values | :white_check_mark: Verified |

      - name: Generate SOPS failure comment
        if: github.event_name == 'pull_request' && steps.validate-sops.outputs.SOPS_FAILED == 'true'
        id: sops-failure-body
        run: |
          {
            echo 'COMMENT_BODY<<EOF'
            echo '## :x: SOPS Encryption Check Failed'
            echo ''
            echo 'The following SOPS files are **NOT properly encrypted**:'
            echo ''
            echo '| File | Status |'
            echo '|------|--------|'
            while IFS= read -r file; do
              if [ -n "$file" ]; then
                echo "| \`$file\` | :x: Unencrypted |"
              fi
            done <<< "${{ steps.validate-sops.outputs.FAILED_FILES }}"
            echo ''
            echo '### Required Actions'
            echo ''
            echo '1. **Encrypt the file(s)** using SOPS:'
            echo '   ```bash'
            echo '   sops --encrypt --in-place <filename>.sops.yaml'
            echo '   ```'
            echo ''
            echo '2. **Verify encryption** by checking for:'
            echo '   - `sops:` metadata section at the end of the file'
            echo '   - Values wrapped in `ENC[AES256_GCM,...]` format'
            echo ''
            echo '3. **If accidentally decrypted**, DO NOT commit plaintext secrets:'
            echo '   ```bash'
            echo '   git checkout -- <filename>.sops.yaml  # Restore encrypted version'
            echo '   ```'
            echo ''
            echo '### Why This Matters'
            echo ''
            echo 'This repository is **public**. Unencrypted SOPS files would expose secrets'
            echo 'in plaintext to anyone who views the repository.'
            echo ''
            echo '**This PR cannot be merged until all SOPS files are properly encrypted.**'
            echo 'EOF'
          } >> "$GITHUB_OUTPUT"

      - name: Comment on PR (SOPS validation failed)
        if: github.event_name == 'pull_request' && steps.validate-sops.outputs.SOPS_FAILED == 'true'
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2.8.2
        with:
          repo-token: ${{ steps.generate-token.outputs.token }}
          message-id: "sops-validation"
          message: ${{ steps.sops-failure-body.outputs.COMMENT_BODY }}

      - name: Fail if SOPS validation failed
        if: steps.validate-sops.outputs.SOPS_FAILED == 'true'
        run: |
          echo "::error::SOPS validation failed! Some files are not properly encrypted."
          echo ""
          echo "Unencrypted files:"
          echo "${{ steps.validate-sops.outputs.FAILED_FILES }}"
          echo ""
          echo "Run: sops --encrypt --in-place <filename>.sops.yaml"
          exit 1

  # =============================================================================
  # Job 3: Combined Status Check for Branch Protection
  # =============================================================================
  security-gate-status:
    name: Security Gate
    needs: ["gitleaks", "sops-validation"]
    runs-on: ubuntu-latest
    if: always()
    steps:
      - name: Check Security Gate Results
        run: |
          echo "Gitleaks result: ${{ needs.gitleaks.result }}"
          echo "SOPS validation result: ${{ needs.sops-validation.result }}"

          # Require explicit success - cancelled/skipped/failure all block the gate
          GITLEAKS_RESULT="${{ needs.gitleaks.result }}"
          SOPS_RESULT="${{ needs.sops-validation.result }}"

          if [ "$GITLEAKS_RESULT" = "cancelled" ]; then
            echo "::error::Gitleaks check was cancelled - security scan incomplete"
            exit 1
          elif [ "$GITLEAKS_RESULT" = "skipped" ]; then
            echo "::error::Gitleaks check was skipped - security scan incomplete"
            exit 1
          elif [ "$GITLEAKS_RESULT" = "failure" ]; then
            echo "::error::Gitleaks check failed - secrets may have been detected"
            exit 1
          elif [ "$GITLEAKS_RESULT" != "success" ]; then
            echo "::error::Gitleaks check did not succeed (result: $GITLEAKS_RESULT)"
            exit 1
          fi

          if [ "$SOPS_RESULT" = "cancelled" ]; then
            echo "::error::SOPS validation was cancelled - encryption check incomplete"
            exit 1
          elif [ "$SOPS_RESULT" = "skipped" ]; then
            echo "::error::SOPS validation was skipped - encryption check incomplete"
            exit 1
          elif [ "$SOPS_RESULT" = "failure" ]; then
            echo "::error::SOPS validation failed - unencrypted secrets may exist"
            exit 1
          elif [ "$SOPS_RESULT" != "success" ]; then
            echo "::error::SOPS validation did not succeed (result: $SOPS_RESULT)"
            exit 1
          fi

          echo "All security checks passed!"
