---
# MCP Server Catalog Sync Workflow
# Automatically generates registry catalog entries from MCPServer CRD definitions
#
# Triggers when MCPServer files are added/modified in PRs
# Validates the MCPServer, checks security, and generates catalog entries
name: "MCP Catalog Sync"

on:
  pull_request:
    branches: ["main"]
    paths:
      # Only trigger on MCPServer CRD additions/modifications
      # registry.json is auto-generated by this workflow, not manually edited
      - "kubernetes/apps/mcp/toolhive-gateway/app/mcpserver-*.yaml"
  workflow_dispatch:
    inputs:
      force_regenerate:
        description: "Force regenerate all catalog entries"
        required: false
        default: "false"
        type: boolean

concurrency:
  group: ${{ github.workflow }}-${{ github.event.number || github.ref }}
  cancel-in-progress: true

# Default to read-only permissions; jobs that need write access override explicitly
permissions:
  contents: read
  pull-requests: read

env:
  MCPSERVER_PATH: "kubernetes/apps/mcp/toolhive-gateway/app"
  REGISTRY_PATH: "kubernetes/apps/mcp/registry-data/registry.json"
  # renovate: datasource=github-releases depName=aquasecurity/trivy
  TRIVY_VERSION: "0.58.2"
  # Tool versions managed by mise (.mise.toml) - yq, thv installed via setup-mcp-tools action

jobs:
  # =============================================================================
  # Job 1: Pre-flight - Detect MCPServer changes
  # =============================================================================
  preflight:
    name: Detect MCP Changes
    runs-on: gha-runner-scale-set
    outputs:
      mcpservers_changed: ${{ steps.changed.outputs.mcpservers_changed }}
      mcpserver_files: ${{ steps.changed.outputs.mcpserver_files }}
      registry_changed: ${{ steps.changed.outputs.registry_changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          fetch-depth: 0

      - name: Detect Changed Files
        id: changed
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.force_regenerate }}" = "true" ]; then
            echo "Force regenerate requested - processing all MCPServer files"
            MCPSERVER_FILES=$(find "${{ env.MCPSERVER_PATH }}" -name "mcpserver-*.yaml" -type f | sort)
            echo "mcpservers_changed=true" >> "$GITHUB_OUTPUT"
            echo "registry_changed=false" >> "$GITHUB_OUTPUT"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            # Get changed files in PR using PR-specific refs
            # Use --diff-filter=d to exclude deleted files for validation (we can't validate files that don't exist)
            CHANGED=$(git diff --name-only --diff-filter=d ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }})
            MCPSERVER_FILES=$(echo "$CHANGED" | grep -E "^${{ env.MCPSERVER_PATH }}/mcpserver-.*\.yaml$" || true)
            REGISTRY_CHANGED=$(echo "$CHANGED" | grep -E "^${{ env.REGISTRY_PATH }}$" || true)

            # Also check for deleted MCPServer files - we still need to regenerate the catalog
            DELETED_MCPSERVERS=$(git diff --name-only --diff-filter=D ${{ github.event.pull_request.base.sha }}..${{ github.event.pull_request.head.sha }} | grep -E "^${{ env.MCPSERVER_PATH }}/mcpserver-.*\.yaml$" || true)

            if [ -n "$MCPSERVER_FILES" ] || [ -n "$DELETED_MCPSERVERS" ]; then
              echo "mcpservers_changed=true" >> "$GITHUB_OUTPUT"
              if [ -n "$DELETED_MCPSERVERS" ]; then
                echo "MCPServer files deleted (catalog will be regenerated):"
                echo "$DELETED_MCPSERVERS"
              fi
            else
              echo "mcpservers_changed=false" >> "$GITHUB_OUTPUT"
            fi

            if [ -n "$REGISTRY_CHANGED" ]; then
              echo "registry_changed=true" >> "$GITHUB_OUTPUT"
            else
              echo "registry_changed=false" >> "$GITHUB_OUTPUT"
            fi
          else
            # workflow_dispatch without force_regenerate - no changes to process
            echo "workflow_dispatch without force_regenerate - skipping"
            MCPSERVER_FILES=""
            echo "mcpservers_changed=false" >> "$GITHUB_OUTPUT"
            echo "registry_changed=false" >> "$GITHUB_OUTPUT"
          fi

          # Store files as JSON array for matrix
          if [ -n "$MCPSERVER_FILES" ]; then
            FILES_JSON=$(echo "$MCPSERVER_FILES" | jq -R -s -c 'split("\n") | map(select(length > 0))')
            echo "mcpserver_files=$FILES_JSON" >> "$GITHUB_OUTPUT"
            echo "MCPServer files to process:"
            echo "$MCPSERVER_FILES"
          else
            echo "mcpserver_files=[]" >> "$GITHUB_OUTPUT"
            echo "No MCPServer files changed"
          fi

  # =============================================================================
  # Job 2: Validate MCPServer definitions
  # =============================================================================
  validate:
    name: Validate MCPServer
    needs: preflight
    # Only run when there are actual files to validate (not just deletions)
    if: needs.preflight.outputs.mcpservers_changed == 'true' && needs.preflight.outputs.mcpserver_files != '[]'
    runs-on: gha-runner-scale-set
    strategy:
      matrix:
        file: ${{ fromJson(needs.preflight.outputs.mcpserver_files) }}
      fail-fast: false
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup MCP Tools
        uses: ./.github/actions/setup-mcp-tools

      - name: Validate YAML Syntax
        run: |
          echo "Validating YAML syntax for: ${{ matrix.file }}"
          yq eval '.' "${{ matrix.file }}" > /dev/null
          echo "YAML syntax is valid"

      - name: Validate Required Fields
        id: validate-fields
        run: |
          FILE="${{ matrix.file }}"
          echo "Validating required fields in: $FILE"

          ERRORS=""

          # Required spec fields
          IMAGE=$(yq eval '.spec.image // ""' "$FILE")
          TRANSPORT=$(yq eval '.spec.transport // ""' "$FILE")
          NAME=$(yq eval '.metadata.name // ""' "$FILE")

          if [ -z "$IMAGE" ]; then
            ERRORS="${ERRORS}Missing required field: spec.image\n"
          fi

          if [ -z "$TRANSPORT" ]; then
            ERRORS="${ERRORS}Missing required field: spec.transport\n"
          fi

          if [ -z "$NAME" ]; then
            ERRORS="${ERRORS}Missing required field: metadata.name\n"
          fi

          # Catalog annotation requirements (for registry generation)
          CATALOG_TITLE=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/catalog-title"] // ""' "$FILE")
          CATALOG_TOOLS=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/catalog-tools"] // ""' "$FILE")
          REPO_URL=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/repository-url"] // ""' "$FILE")

          # Warn if catalog annotations missing (not fatal, but needed for catalog)
          WARNINGS=""
          if [ -z "$CATALOG_TITLE" ]; then
            WARNINGS="${WARNINGS}Missing annotation: toolhive.stacklok.dev/catalog-title\n"
          fi
          if [ -z "$CATALOG_TOOLS" ]; then
            WARNINGS="${WARNINGS}Missing annotation: toolhive.stacklok.dev/catalog-tools\n"
          fi
          if [ -z "$REPO_URL" ]; then
            WARNINGS="${WARNINGS}Missing annotation: toolhive.stacklok.dev/repository-url\n"
          fi

          if [ -n "$ERRORS" ]; then
            echo "::error::Validation failed for $FILE"
            echo -e "$ERRORS"
            exit 1
          fi

          if [ -n "$WARNINGS" ]; then
            echo "::warning::$FILE is missing catalog annotations - catalog entry may be incomplete"
            echo -e "$WARNINGS"
          fi

          echo "Validation passed for $FILE"
          echo "name=$NAME" >> "$GITHUB_OUTPUT"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"

      - name: Check for Hardcoded Secrets
        run: |
          FILE="${{ matrix.file }}"
          echo "Checking for hardcoded secrets in: $FILE"

          # Patterns that suggest hardcoded secrets
          PATTERNS=(
            "password:"
            "api_key:"
            "apiKey:"
            "secret:"
            "token:"
            "sk-"
            "Bearer "
            "ghp_"
            "gho_"
            "glpat-"
            "PRIVATE_KEY"
            "private.key"
            "AWS_SECRET"
          )

          FOUND=""
          for pattern in "${PATTERNS[@]}"; do
            # Check env values (not names or references to secrets)
            if yq eval '.spec.env[].value' "$FILE" 2>/dev/null | grep -qi "$pattern"; then
              FOUND="${FOUND}Potential secret pattern found: $pattern\n"
            fi
          done

          if [ -n "$FOUND" ]; then
            echo "::error::Potential hardcoded secrets detected in $FILE"
            echo -e "$FOUND"
            echo "Use spec.secrets with ExternalSecrets instead of hardcoding values"
            exit 1
          fi

          echo "No hardcoded secrets detected"

  # =============================================================================
  # Job 3: Security scan container images (optional but recommended)
  # =============================================================================
  image-scan:
    name: Scan Container Image
    needs: [preflight, validate]
    # Only run when there are actual files to scan (not just deletions)
    if: |
      always() &&
      needs.preflight.outputs.mcpservers_changed == 'true' &&
      needs.preflight.outputs.mcpserver_files != '[]' &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    runs-on: gha-runner-scale-set
    strategy:
      matrix:
        file: ${{ fromJson(needs.preflight.outputs.mcpserver_files) }}
      fail-fast: false
    continue-on-error: true  # Don't block PR on scan failures, just warn
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup MCP Tools
        uses: ./.github/actions/setup-mcp-tools

      - name: Extract Image
        id: image
        run: |
          IMAGE=$(yq eval '.spec.image' "${{ matrix.file }}")
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "Scanning image: $IMAGE"

      - name: Run Trivy Scan
        uses: aquasecurity/trivy-action@915b19bbe73b92a6cf82a1bc12b087c9a19a5fe2 # v0.28.0
        with:
          image-ref: ${{ steps.image.outputs.image }}
          format: "table"
          exit-code: "0"  # Don't fail, just report
          severity: "HIGH,CRITICAL"
          ignore-unfixed: true

  # =============================================================================
  # Job 4: MCP Protocol Validation (optional - requires thv CLI)
  # =============================================================================
  mcp-validate:
    name: Validate MCP Protocol
    needs: [preflight, validate]
    # Only run when there are actual files to validate (not just deletions)
    if: |
      always() &&
      needs.preflight.outputs.mcpservers_changed == 'true' &&
      needs.preflight.outputs.mcpserver_files != '[]' &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    runs-on: gha-runner-scale-set
    strategy:
      matrix:
        file: ${{ fromJson(needs.preflight.outputs.mcpserver_files) }}
      fail-fast: false
    continue-on-error: true  # Don't block PR - MCP servers may need external deps
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2

      - name: Setup MCP Tools
        uses: ./.github/actions/setup-mcp-tools

      - name: Extract MCP Server Config
        id: config
        run: |
          FILE="${{ matrix.file }}"
          NAME=$(yq eval '.metadata.name' "$FILE")
          IMAGE=$(yq eval '.spec.image' "$FILE")
          TRANSPORT=$(yq eval '.spec.transport' "$FILE")
          DECLARED_TOOLS=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/catalog-tools"] // ""' "$FILE")

          echo "name=$NAME" >> "$GITHUB_OUTPUT"
          echo "image=$IMAGE" >> "$GITHUB_OUTPUT"
          echo "transport=$TRANSPORT" >> "$GITHUB_OUTPUT"
          echo "declared_tools=$DECLARED_TOOLS" >> "$GITHUB_OUTPUT"

          echo "MCP Server: $NAME"
          echo "Image: $IMAGE"
          echo "Transport: $TRANSPORT"
          echo "Declared tools: $DECLARED_TOOLS"

      - name: Start MCP Server Container
        id: start-server
        run: |
          IMAGE="${{ steps.config.outputs.image }}"
          NAME="${{ steps.config.outputs.name }}"
          TRANSPORT="${{ steps.config.outputs.transport }}"

          echo "Starting MCP server container for validation..."

          # For stdio transport, we can't easily test without running thv
          # For streamable-http, we can start the container and probe it
          if [ "$TRANSPORT" = "streamable-http" ]; then
            # Start container with default port
            docker run -d --name "mcp-test-$NAME" \
              -p 8080:8080 \
              -e SERVER__PORT=8080 \
              "$IMAGE" || {
                echo "::warning::Failed to start container - may need required env vars"
                echo "started=false" >> "$GITHUB_OUTPUT"
                exit 0
              }

            # Wait for container to be ready with poll-based health check
            READY=false
            for i in {1..30}; do
              if ! docker ps | grep -q "mcp-test-$NAME"; then
                echo "::warning::Container exited after ${i}s"
                break
              fi
              # Check if MCP endpoint responds
              if curl -sf http://localhost:8080/mcp >/dev/null 2>&1 || \
                 curl -sf http://localhost:8080/health >/dev/null 2>&1; then
                echo "Container ready after ${i}s"
                READY=true
                break
              fi
              sleep 1
            done

            # Set output based on readiness
            if [ "$READY" = "true" ]; then
              echo "started=true" >> "$GITHUB_OUTPUT"
              echo "url=http://localhost:8080/mcp" >> "$GITHUB_OUTPUT"
            else
              echo "::warning::Container not ready after 30s - likely missing required dependencies"
              docker logs "mcp-test-$NAME" 2>&1 | tail -20 || true
              echo "started=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "::notice::stdio transport - using thv for validation"
            echo "started=skip" >> "$GITHUB_OUTPUT"
          fi

      - name: Validate MCP Tools (HTTP transport)
        if: steps.start-server.outputs.started == 'true'
        run: |
          URL="${{ steps.start-server.outputs.url }}"
          DECLARED="${{ steps.config.outputs.declared_tools }}"

          echo "Querying MCP server at $URL..."

          # Use thv to list tools
          TOOLS_JSON=$(thv mcp list tools --server "$URL" --format json 2>/dev/null) || {
            echo "::warning::Could not query MCP tools - server may not be ready"
            exit 0
          }

          echo "Tools returned by server:"
          echo "$TOOLS_JSON" | jq -r '.[].name' 2>/dev/null || echo "$TOOLS_JSON"

          # Compare with declared tools if provided
          if [ -n "$DECLARED" ]; then
            echo ""
            echo "Comparing with declared tools in annotations..."
            ACTUAL_TOOLS=$(echo "$TOOLS_JSON" | jq -r '.[].name' | sort | tr '\n' ',' | sed 's/,$//')
            DECLARED_SORTED=$(echo "$DECLARED" | tr ',' '\n' | sort | tr '\n' ',' | sed 's/,$//')

            if [ "$ACTUAL_TOOLS" != "$DECLARED_SORTED" ]; then
              echo "::warning::Tool mismatch detected"
              echo "Declared: $DECLARED_SORTED"
              echo "Actual: $ACTUAL_TOOLS"
            else
              echo "Tools match declared annotations"
            fi
          fi

      - name: Validate MCP Tools (stdio transport)
        if: steps.start-server.outputs.started == 'skip'
        run: |
          IMAGE="${{ steps.config.outputs.image }}"
          NAME="${{ steps.config.outputs.name }}"

          echo "Validating stdio MCP server using thv run..."

          # Try to run with thv and list tools
          # This may fail if the server needs specific env vars
          timeout 30 thv run --name "test-$NAME" "$IMAGE" &
          THV_PID=$!

          # Poll until server responds or timeout (max 20s)
          TOOLS_RESULT=""
          for i in {1..10}; do
            if TOOLS_RESULT=$(thv mcp list tools --server "test-$NAME" --format json 2>/dev/null); then
              echo "Server ready after $((i * 2))s"
              echo "$TOOLS_RESULT"
              break
            fi
            sleep 2
          done

          # Check if we got tools
          if [ -z "$TOOLS_RESULT" ]; then
            echo "::warning::Could not query stdio MCP server - may need required env vars"
          fi

          kill $THV_PID 2>/dev/null || true

      - name: Cleanup
        if: always()
        run: |
          NAME="${{ steps.config.outputs.name }}"
          docker rm -f "mcp-test-$NAME" 2>/dev/null || true
          thv rm "test-$NAME" 2>/dev/null || true

  # =============================================================================
  # Job 5: Generate Registry Catalog Entry
  # =============================================================================
  generate-catalog:
    name: Generate Catalog Entry
    needs: [preflight, validate]
    # Run when MCPServers changed AND validate passed or was skipped (deletions only)
    if: |
      always() &&
      needs.preflight.outputs.mcpservers_changed == 'true' &&
      (needs.validate.result == 'success' || needs.validate.result == 'skipped')
    runs-on: gha-runner-scale-set
    permissions:
      contents: write       # Required: Auto-commit registry.json changes to PR
      pull-requests: write  # Required: Add status comment to PR
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
        with:
          ref: ${{ github.head_ref }}
          fetch-depth: 0

      - name: Setup MCP Tools
        uses: ./.github/actions/setup-mcp-tools

      - name: Generate Registry Entries
        id: generate
        run: |
          # Process all MCPServer files and generate registry.json
          # Using MCP Registry API upstream format for clean names and full metadata
          # Name format: owner/repo from repository URL (e.g., getzep/graphiti)
          REGISTRY_FILE="${{ env.REGISTRY_PATH }}"
          MCPSERVER_DIR="${{ env.MCPSERVER_PATH }}"
          TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # Start building servers array (upstream format)
          SERVERS="[]"
          SERVER_COUNT=0

          for mcpfile in "$MCPSERVER_DIR"/mcpserver-*.yaml; do
            [ -f "$mcpfile" ] || continue

            echo "Processing: $mcpfile"

            # Extract metadata from MCPServer
            K8S_NAME=$(yq eval '.metadata.name' "$mcpfile")
            TITLE=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/catalog-title"] // ""' "$mcpfile")
            DESCRIPTION=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/registry-description"] // "No description available"' "$mcpfile")
            TOOLS_CSV=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/catalog-tools"] // ""' "$mcpfile")
            TAGS_CSV=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/catalog-tags"] // "mcp"' "$mcpfile")
            REPO_URL=$(yq eval '.metadata.annotations["toolhive.stacklok.dev/repository-url"] // ""' "$mcpfile")

            # Extract image and version from tag
            IMAGE=$(yq eval '.spec.image' "$mcpfile")
            VERSION=$(echo "$IMAGE" | sed -E 's/.*:([^:]+)$/\1/')
            [ "$VERSION" = "$IMAGE" ] && VERSION="latest"

            # Extract proxyMode for remote transport type
            PROXY_MODE=$(yq eval '.spec.proxyMode // "streamable-http"' "$mcpfile")

            # Build server name from repository URL (owner/repo format)
            # e.g., https://github.com/getzep/graphiti -> getzep/graphiti
            if [ -n "$REPO_URL" ]; then
              SERVER_NAME=$(echo "$REPO_URL" | sed -E 's|https?://github\.com/([^/]+/[^/]+).*|\1|')
              REPO_SOURCE="github"
            else
              SERVER_NAME="homelab/${K8S_NAME}"
              REPO_SOURCE="unknown"
            fi

            # If title not set, generate from server name
            if [ -z "$TITLE" ]; then
              TITLE=$(echo "$K8S_NAME" | sed 's/-/ /g' | sed 's/\b\(.\)/\u\1/g')
            fi

            # Convert CSV to JSON arrays
            TOOLS_JSON=$(echo "$TOOLS_CSV" | tr ',' '\n' | jq -R -s -c 'split("\n") | map(select(length > 0) | gsub("^\\s+|\\s+$"; ""))')
            TAGS_JSON=$(echo "$TAGS_CSV" | tr ',' '\n' | jq -R -s -c 'split("\n") | map(select(length > 0) | gsub("^\\s+|\\s+$"; ""))')

            # Build the endpoint URL (uses k8s name for routing)
            ENDPOINT_URL="https://mcp.homelab0.org/servers/${K8S_NAME}/mcp"

            # Create server entry in upstream format
            SERVER_ENTRY=$(jq -n \
              --arg name "$SERVER_NAME" \
              --arg title "$TITLE" \
              --arg description "$DESCRIPTION" \
              --arg version "$VERSION" \
              --arg repo_url "$REPO_URL" \
              --arg repo_source "$REPO_SOURCE" \
              --arg remote_type "$PROXY_MODE" \
              --arg endpoint_url "$ENDPOINT_URL" \
              --argjson tools "$TOOLS_JSON" \
              --argjson tags "$TAGS_JSON" \
              '{
                "name": $name,
                "title": $title,
                "description": $description,
                "version": $version,
                "repository": {
                  "url": $repo_url,
                  "source": $repo_source
                },
                "remotes": [
                  {
                    "type": $remote_type,
                    "url": $endpoint_url
                  }
                ],
                "tools": $tools,
                "tags": $tags
              }')

            # Add to servers array
            SERVERS=$(echo "$SERVERS" | jq --argjson entry "$SERVER_ENTRY" '. + [$entry]')
            SERVER_COUNT=$((SERVER_COUNT + 1))

            echo "  Added: $SERVER_NAME (version: $VERSION)"
          done

          # Build final registry.json in upstream format
          REGISTRY=$(jq -n \
            --arg schema "https://raw.githubusercontent.com/stacklok/toolhive-registry-server/main/internal/registry/upstream-registry.schema.json" \
            --arg timestamp "$TIMESTAMP" \
            --argjson servers "$SERVERS" \
            '{
              "$schema": $schema,
              "version": "1.0.0",
              "meta": {
                "last_updated": $timestamp
              },
              "data": {
                "servers": $servers
              }
            }')

          # Write registry.json
          echo "$REGISTRY" | jq '.' > "$REGISTRY_FILE"

          echo "Generated registry with $SERVER_COUNT servers (upstream format)"
          echo "servers_count=$SERVER_COUNT" >> "$GITHUB_OUTPUT"

      - name: Check for Changes
        id: check-changes
        run: |
          # Compare registry content excluding timestamp to avoid unnecessary commits
          # Upstream format uses meta.last_updated
          CURRENT=$(cat "${{ env.REGISTRY_PATH }}" | jq 'del(.meta.last_updated)' | jq -S '.')
          PREVIOUS=$(git show HEAD:"${{ env.REGISTRY_PATH }}" 2>/dev/null | jq 'del(.meta.last_updated) | del(.last_updated)' | jq -S '.' || echo "{}")

          if [ "$CURRENT" = "$PREVIOUS" ]; then
            echo "No meaningful changes to registry.json (only timestamp differs)"
            echo "has_changes=false" >> "$GITHUB_OUTPUT"
            # Restore original file to avoid committing timestamp-only changes
            git checkout "${{ env.REGISTRY_PATH }}"
          else
            echo "Registry.json has meaningful updates"
            echo "has_changes=true" >> "$GITHUB_OUTPUT"
            git diff "${{ env.REGISTRY_PATH }}"
          fi

      - name: Generate GitHub App Token
        if: steps.check-changes.outputs.has_changes == 'true'
        id: generate-token
        uses: actions/create-github-app-token@67018539274d69449ef7c02e8e71183d1719ab42 # v2
        with:
          app-id: ${{ secrets.BOT_APP_ID }}
          private-key: ${{ secrets.BOT_APP_PRIVATE_KEY }}

      - name: Commit Catalog Changes
        if: steps.check-changes.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ steps.generate-token.outputs.token }}
        run: |
          # Configure git for GitHub App bot
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"

          # Use GitHub App token for push authentication
          git remote set-url origin "https://x-access-token:${GH_TOKEN}@github.com/${{ github.repository }}.git"

          git add "${{ env.REGISTRY_PATH }}"
          git commit -m "chore(mcp): auto-generate registry catalog from MCPServer CRDs

          Generated ${{ steps.generate.outputs.servers_count }} catalog entries from MCPServer definitions."
          git push

      - name: Comment on PR
        if: steps.check-changes.outputs.has_changes == 'true'
        uses: mshick/add-pr-comment@b8f338c590a895d50bcbfa6c5859251edc8952fc # v2.8.2
        with:
          repo-token: ${{ steps.generate-token.outputs.token }}
          message-id: "mcp-catalog-sync"
          message: |
            ## :sparkles: MCP Catalog Updated

            The registry catalog has been automatically updated from MCPServer CRD definitions.

            | Metric | Value |
            |--------|-------|
            | Servers in catalog | ${{ steps.generate.outputs.servers_count }} |
            | Last updated | ${{ github.sha }} |

            **Changes committed to this PR.** The catalog will be available after merge.

  # =============================================================================
  # Job 6: Status Check
  # =============================================================================
  mcp-catalog-status:
    name: MCP Catalog Sync Status
    needs: [preflight, validate, image-scan, mcp-validate, generate-catalog]
    if: always()
    runs-on: gha-runner-scale-set
    steps:
      - name: Check Results
        run: |
          echo "=== Job Results ==="
          echo "Preflight: ${{ needs.preflight.result }}"
          echo "Validate: ${{ needs.validate.result }}"
          echo "Image Scan: ${{ needs.image-scan.result }}"
          echo "MCP Validate: ${{ needs.mcp-validate.result }}"
          echo "Generate Catalog: ${{ needs.generate-catalog.result }}"
          echo ""

          # Only require validation and catalog generation to pass if MCPServers changed
          if [ "${{ needs.preflight.outputs.mcpservers_changed }}" = "true" ]; then
            # Validate is required only when there are files to validate (not just deletions)
            # When validate is skipped (due to empty matrix from deletions), that's OK
            if [ "${{ needs.validate.result }}" = "failure" ]; then
              echo "::error::MCPServer validation failed"
              exit 1
            fi

            # Generate-catalog is required when MCPServers change (additions or deletions)
            if [ "${{ needs.generate-catalog.result }}" = "failure" ]; then
              echo "::error::Catalog generation failed"
              exit 1
            fi
          fi

          # Report on optional jobs (non-blocking)
          if [ "${{ needs.image-scan.result }}" = "failure" ]; then
            echo "::warning::Image vulnerability scan reported issues - review recommended"
          fi

          if [ "${{ needs.mcp-validate.result }}" = "failure" ]; then
            echo "::warning::MCP protocol validation failed - server may need external dependencies"
          fi

          echo "MCP Catalog Sync completed successfully"
