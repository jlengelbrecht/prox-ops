---
# STORY-031-2: Voice Bridge Application Code
# ConfigMap containing the Pipecat-based voice bridge Python application
apiVersion: v1
kind: ConfigMap
metadata:
  name: voice-bridge-app
  namespace: ai
data:
  # Main server application - FastAPI + Twilio WebSocket handling
  server.py: |
    """
    Voice Bridge Server - Connects Twilio phone calls to LiteLLM AI infrastructure
    
    EPIC-031: Voice Calling Capability
    
    Endpoints:
    - POST /api/v1/calls - Initiate outbound call
    - GET /api/v1/calls/{call_id} - Get call status
    - GET /health - Health check
    - WebSocket /ws - Twilio Media Streams handler
    """
    
    import os
    import asyncio
    import uuid
    import json
    import logging
    from datetime import datetime
    from typing import Dict, Optional
    from contextlib import asynccontextmanager
    
    from fastapi import FastAPI, WebSocket, WebSocketDisconnect, HTTPException
    from fastapi.responses import Response
    from pydantic import BaseModel
    from twilio.rest import Client as TwilioClient
    from twilio.twiml.voice_response import VoiceResponse, Connect
    
    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger("voice-bridge")
    
    # Environment configuration
    TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID")
    TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN")
    TWILIO_PHONE_NUMBER = os.getenv("TWILIO_PHONE_NUMBER")
    LITELLM_API_KEY = os.getenv("LITELLM_API_KEY")
    LITELLM_BASE_URL = os.getenv("LITELLM_BASE_URL", "http://litellm.ai.svc.cluster.local:4000/v1")
    VOICE_BRIDGE_HOST = os.getenv("VOICE_BRIDGE_HOST", "voice-bridge.homelab0.org")
    RECORDINGS_DIR = os.getenv("RECORDINGS_DIR", "/recordings")
    
    # In-memory call tracking (consider Redis for production scaling)
    active_calls: Dict[str, dict] = {}
    
    
    class CallRequest(BaseModel):
        """Request model for initiating a call"""
        to: str  # Phone number to call (+1xxxxxxxxxx)
        context: Optional[str] = "You are a helpful AI assistant."
        voice: Optional[str] = "alloy"  # Voice persona for TTS
        from_number: Optional[str] = None  # Override default Twilio number
    
    
    class CallStatus(BaseModel):
        """Response model for call status"""
        call_id: str
        status: str  # pending, in_progress, completed, failed
        to: str
        from_number: str
        started_at: Optional[str] = None
        ended_at: Optional[str] = None
        duration_seconds: Optional[int] = None
        recording_url: Optional[str] = None
        transcript: Optional[str] = None
        error: Optional[str] = None
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        """Application lifespan handler"""
        logger.info("Voice Bridge starting up...")
        logger.info(f"LiteLLM Base URL: {LITELLM_BASE_URL}")
        logger.info(f"Twilio Phone: {TWILIO_PHONE_NUMBER}")
        
        # Validate required environment variables - fail fast if missing
        missing_vars = []
        if not TWILIO_ACCOUNT_SID:
            missing_vars.append("TWILIO_ACCOUNT_SID")
        if not TWILIO_AUTH_TOKEN:
            missing_vars.append("TWILIO_AUTH_TOKEN")
        if not TWILIO_PHONE_NUMBER:
            missing_vars.append("TWILIO_PHONE_NUMBER")
        if not LITELLM_API_KEY:
            missing_vars.append("LITELLM_API_KEY")

        if missing_vars:
            raise RuntimeError(f"Missing required environment variables: {', '.join(missing_vars)}")
        
        yield
        
        logger.info("Voice Bridge shutting down...")
    
    
    app = FastAPI(
        title="Voice Bridge",
        description="Pipecat-based voice bridge for AI phone calls",
        version="1.0.0",
        lifespan=lifespan
    )
    
    
    @app.get("/health")
    async def health_check():
        """Health check endpoint for Kubernetes probes"""
        return {
            "status": "healthy",
            "service": "voice-bridge",
            "timestamp": datetime.utcnow().isoformat(),
            "active_calls": len(active_calls)
        }
    
    
    @app.post("/api/v1/calls", response_model=CallStatus)
    async def initiate_call(request: CallRequest):
        """
        Initiate an outbound phone call
        
        The call flow:
        1. Create Twilio call with TwiML pointing to our WebSocket
        2. Twilio connects and streams audio to our WebSocket
        3. Pipecat handles STT -> LLM -> TTS pipeline
        4. Audio streamed back to Twilio and the caller
        """
        if not all([TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN]):
            raise HTTPException(status_code=503, detail="Twilio not configured")
        
        call_id = str(uuid.uuid4())
        from_number = request.from_number or TWILIO_PHONE_NUMBER
        
        # Store call metadata
        active_calls[call_id] = {
            "call_id": call_id,
            "to": request.to,
            "from_number": from_number,
            "context": request.context,
            "voice": request.voice,
            "status": "pending",
            "started_at": datetime.utcnow().isoformat(),
            "twilio_sid": None,
            "transcript": [],
            "error": None
        }
        
        try:
            # Initialize Twilio client
            client = TwilioClient(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)
            
            # Create TwiML that connects to our WebSocket
            # Twilio will stream audio to wss://voice-bridge.homelab0.org/ws/{call_id}
            ws_url = f"wss://{VOICE_BRIDGE_HOST}/ws/{call_id}"
            
            # Create the call using asyncio.to_thread to avoid blocking event loop
            twiml_content = f'''
                <Response>
                    <Connect>
                        <Stream url="{ws_url}">
                            <Parameter name="call_id" value="{call_id}"/>
                        </Stream>
                    </Connect>
                </Response>
            '''
            call = await asyncio.to_thread(
                client.calls.create,
                to=request.to,
                from_=from_number,
                twiml=twiml_content
            )
            
            active_calls[call_id]["twilio_sid"] = call.sid
            active_calls[call_id]["status"] = "in_progress"
            
            logger.info(f"Call initiated: {call_id} -> {request.to}")
            
            return CallStatus(**{
                "call_id": call_id,
                "status": "in_progress",
                "to": request.to,
                "from_number": from_number,
                "started_at": active_calls[call_id]["started_at"]
            })
            
        except Exception as e:
            logger.error(f"Failed to initiate call {call_id}: {e}")
            active_calls[call_id]["status"] = "failed"
            active_calls[call_id]["error"] = str(e)
            raise HTTPException(status_code=500, detail=str(e))
    
    
    @app.get("/api/v1/calls/{call_id}", response_model=CallStatus)
    async def get_call_status(call_id: str):
        """Get the status of a call"""
        if call_id not in active_calls:
            raise HTTPException(status_code=404, detail="Call not found")
        
        call = active_calls[call_id]
        
        # Calculate duration if call has ended
        duration = None
        if call.get("ended_at") and call.get("started_at"):
            start = datetime.fromisoformat(call["started_at"])
            end = datetime.fromisoformat(call["ended_at"])
            duration = int((end - start).total_seconds())
        
        return CallStatus(
            call_id=call["call_id"],
            status=call["status"],
            to=call["to"],
            from_number=call["from_number"],
            started_at=call.get("started_at"),
            ended_at=call.get("ended_at"),
            duration_seconds=duration,
            recording_url=call.get("recording_url"),
            transcript="\n".join(call.get("transcript", [])) if call.get("transcript") else None,
            error=call.get("error")
        )
    
    
    @app.websocket("/ws/{call_id}")
    async def websocket_handler(websocket: WebSocket, call_id: str):
        """
        Handle Twilio Media Stream WebSocket connection
        
        This is where the magic happens:
        1. Receive audio from Twilio (mulaw 8kHz)
        2. Feed to Pipecat pipeline (STT -> LLM -> TTS)
        3. Stream audio back to Twilio
        """
        await websocket.accept()
        logger.info(f"WebSocket connected for call: {call_id}")
        
        if call_id not in active_calls:
            logger.warning(f"Unknown call_id: {call_id}")
            # Create a new entry for inbound calls
            active_calls[call_id] = {
                "call_id": call_id,
                "status": "in_progress",
                "started_at": datetime.utcnow().isoformat(),
                "transcript": []
            }
        
        try:
            # Import Pipecat components here to avoid startup delays
            from bot import run_pipeline
            
            # Create and run the Pipecat pipeline
            call_data = active_calls[call_id]
            await run_pipeline(
                websocket=websocket,
                call_id=call_id,
                context=call_data.get("context", "You are a helpful AI assistant."),
                voice=call_data.get("voice", "alloy"),
                litellm_base_url=LITELLM_BASE_URL,
                litellm_api_key=LITELLM_API_KEY,
                transcript_callback=lambda msg: active_calls[call_id]["transcript"].append(msg)
            )
            
        except WebSocketDisconnect:
            logger.info(f"WebSocket disconnected for call: {call_id}")
        except Exception as e:
            logger.error(f"Error in WebSocket handler for {call_id}: {e}")
            if call_id in active_calls:
                active_calls[call_id]["error"] = str(e)
        finally:
            if call_id in active_calls:
                active_calls[call_id]["status"] = "completed"
                active_calls[call_id]["ended_at"] = datetime.utcnow().isoformat()
            logger.info(f"Call ended: {call_id}")
    
    
    @app.post("/twiml/answer")
    async def twiml_answer():
        """
        TwiML endpoint for inbound calls
        Returns TwiML that connects to our WebSocket
        """
        call_id = str(uuid.uuid4())
        ws_url = f"wss://{VOICE_BRIDGE_HOST}/ws/{call_id}"
        
        response = VoiceResponse()
        connect = Connect()
        connect.stream(url=ws_url, name="voice-bridge")
        response.append(connect)
        
        return Response(
            content=str(response),
            media_type="application/xml"
        )
    
    
    if __name__ == "__main__":
        import uvicorn
        uvicorn.run(app, host="0.0.0.0", port=8080)

  # Pipecat pipeline - STT -> LLM -> TTS using LiteLLM
  bot.py: |
    """
    Voice Bridge Bot - Pipecat pipeline for voice conversations
    
    Audio Pipeline:
    - STT: Whisper via LiteLLM (whisper-medium model)
    - LLM: Claude via LiteLLM
    - TTS: Qwen-TTS via LiteLLM
    
    Audio format: Twilio uses mulaw 8kHz, Pipecat handles conversion
    """
    
    import os
    import asyncio
    import logging
    from typing import Callable, Optional
    
    from pipecat.pipeline.pipeline import Pipeline
    from pipecat.pipeline.runner import PipelineRunner
    from pipecat.pipeline.task import PipelineParams, PipelineTask
    from pipecat.frames.frames import EndFrame, LLMMessagesFrame
    from pipecat.processors.aggregators.openai_llm_context import OpenAILLMContext
    from pipecat.services.openai.llm import OpenAILLMService
    from pipecat.services.openai.stt import OpenAISTTService
    from pipecat.services.openai.tts import OpenAITTSService
    from pipecat.transports.network.fastapi_websocket import FastAPIWebsocketTransport
    from pipecat.serializers.twilio import TwilioFrameSerializer
    from pipecat.vad.silero import SileroVADAnalyzer
    
    logger = logging.getLogger("voice-bridge.bot")
    
    
    async def run_pipeline(
        websocket,
        call_id: str,
        context: str,
        voice: str,
        litellm_base_url: str,
        litellm_api_key: str,
        transcript_callback: Optional[Callable[[str], None]] = None
    ):
        """
        Create and run the Pipecat voice pipeline
        
        Args:
            websocket: FastAPI WebSocket connection
            call_id: Unique call identifier
            context: System prompt for the LLM
            voice: Voice persona for TTS
            litellm_base_url: LiteLLM API base URL
            litellm_api_key: LiteLLM API key
            transcript_callback: Callback for transcript updates
        """
        logger.info(f"Starting pipeline for call: {call_id}")
        
        # Create Twilio frame serializer for audio format conversion
        # Twilio uses mulaw 8kHz, Pipecat handles the conversion
        serializer = TwilioFrameSerializer(
            stream_sid=call_id,  # Use call_id as stream identifier
        )
        
        # Create transport with Silero VAD for voice activity detection
        transport = FastAPIWebsocketTransport(
            websocket=websocket,
            params=FastAPIWebsocketTransport.InputParams(
                audio_in_sample_rate=8000,
                audio_out_sample_rate=8000,
                serializer=serializer,
                vad_analyzer=SileroVADAnalyzer(),
            )
        )
        
        # STT Service - Whisper via LiteLLM
        # Uses the whisper-medium model configured in LiteLLM
        stt = OpenAISTTService(
            api_key=litellm_api_key,
            base_url=litellm_base_url,
            model="whisper-medium",
        )
        
        # LLM Service - Claude via LiteLLM
        # Uses claude-default which routes to Claude Opus
        llm = OpenAILLMService(
            api_key=litellm_api_key,
            base_url=litellm_base_url,
            model="claude-default",
        )
        
        # TTS Service - Qwen-TTS via LiteLLM
        # Uses qwen-tts model with specified voice
        tts = OpenAITTSService(
            api_key=litellm_api_key,
            base_url=litellm_base_url,
            model="qwen-tts",
            voice=voice,
        )
        
        # Create LLM context with system prompt
        messages = [
            {
                "role": "system",
                "content": f"""You are having a phone conversation. {context}
                
    Keep your responses concise and conversational - this is a voice call, not text chat.
    Speak naturally as if talking on the phone. Avoid long monologues.
    If you don't understand something, ask for clarification.
    """
            }
        ]
        
        context_obj = OpenAILLMContext(messages)
        context_aggregator = llm.create_context_aggregator(context_obj)
        
        # Build the pipeline
        # Flow: transport input -> STT -> context -> LLM -> TTS -> transport output
        pipeline = Pipeline([
            transport.input(),
            stt,
            context_aggregator.user(),
            llm,
            tts,
            transport.output(),
            context_aggregator.assistant(),
        ])
        
        # Create pipeline task with audio parameters
        task = PipelineTask(
            pipeline,
            params=PipelineParams(
                allow_interruptions=True,
                enable_metrics=True,
                audio_in_sample_rate=8000,
                audio_out_sample_rate=8000,
            )
        )
        
        # Event handlers
        @transport.event_handler("on_client_connected")
        async def on_connected(transport, client):
            logger.info(f"Client connected: {call_id}")
            # Send initial greeting
            messages.append({
                "role": "assistant",
                "content": "Hello! How can I help you today?"
            })
            await task.queue_frames([LLMMessagesFrame(messages)])
        
        @transport.event_handler("on_client_disconnected")
        async def on_disconnected(transport, client):
            logger.info(f"Client disconnected: {call_id}")
            await task.queue_frames([EndFrame()])
        
        # Run the pipeline
        runner = PipelineRunner()
        await runner.run(task)
        
        logger.info(f"Pipeline completed for call: {call_id}")

  # Requirements file for pip install
  # Versions pinned for reproducibility (Renovate will update via configmap annotations)
  requirements.txt: |
    # Pipecat dependencies (includes websockets~=13.1)
    pipecat-ai[openai,silero]==0.0.48
    # Server dependencies
    fastapi==0.115.0
    uvicorn==0.32.0
    # Twilio SDK
    twilio==9.4.0
