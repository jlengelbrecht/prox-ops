---
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: lightrag
  namespace: ai
spec:
  chart:
    spec:
      chart: app-template
      # renovate: datasource=helm registryUrl=https://bjw-s.github.io/helm-charts
      version: 4.4.0
      sourceRef:
        kind: HelmRepository
        name: bjw-s
        namespace: ai
  interval: 1h
  values:
    controllers:
      lightrag:
        # Recreate strategy for RWO PVC compatibility
        strategy: Recreate
        containers:
          app:
            image:
              repository: ghcr.io/hkuds/lightrag
              # renovate: datasource=docker depName=ghcr.io/hkuds/lightrag
              tag: v1.4.9.8
            # Patch upstream pydantic bug: file_path must be Optional for API-submitted text documents
            # Bug: DocStatusResponse.file_path is defined as `str` but is `None` for text submissions
            # Fix: Copy ENTIRE /app/lightrag to /tmp (writable), patch there, use wrapper with sys.path
            # Critical: /app/lightrag is imported BEFORE venv because '' (cwd) is first in sys.path
            command:
              - /bin/sh
              - -c
              - |
                # Copy ENTIRE /app/lightrag package to /tmp (required because Python imports /app/lightrag, NOT venv)
                echo "Copying /app/lightrag to /tmp for patching..."
                cp -r /app/lightrag /tmp/lightrag

                # Patch the pydantic model in /tmp/lightrag
                TARGET_FILE="/tmp/lightrag/api/routers/document_routes.py"
                if [ ! -f "$TARGET_FILE" ]; then
                  echo "ERROR: Could not find $TARGET_FILE"
                  exit 1
                fi

                # Apply patch: file_path: str -> file_path: Optional[str] = Field(default=None, ...)
                sed -i 's/file_path: str = Field(description="Path to the document file")/file_path: Optional[str] = Field(default=None, description="Path to the document file")/' "$TARGET_FILE"

                # Verify patch applied
                if grep -q 'file_path: Optional\[str\] = Field(default=None' "$TARGET_FILE"; then
                  echo "SUCCESS: Pydantic patch applied to $TARGET_FILE"
                else
                  echo "ERROR: Runtime patch failed - upstream code may have changed"
                  echo "Searching for file_path definition:"
                  grep -n "file_path.*Field" "$TARGET_FILE" || echo "No file_path Field found"
                  exit 1
                fi

                # Create Python wrapper that manipulates sys.path BEFORE any imports
                # This ensures our patched /tmp/lightrag is found before /app/lightrag
                cat > /tmp/run_lightrag.py << 'PYEOF'
                import sys

                # CRITICAL: Remove '' (current working directory /app) and /app from sys.path
                # Otherwise Python finds /app/lightrag before our patched /tmp/lightrag
                sys.path = ['/tmp'] + [p for p in sys.path if p not in ('', '/app')]
                print(f"sys.path configured: {sys.path[:5]}...")

                # Import patched module (startup aborts if wrong module loaded)
                from lightrag.api.routers import document_routes
                print(f"Loaded document_routes from: {document_routes.__file__}")

                if '/tmp/' not in document_routes.__file__:
                    print("ERROR: Loaded wrong module! Expected /tmp/lightrag")
                    sys.exit(1)

                # Run the actual server
                from lightrag.api.lightrag_server import main
                main()
                PYEOF

                exec python /tmp/run_lightrag.py
            env:
              # Server Configuration
              HOST: "0.0.0.0"
              PORT: "9621"
              WORKERS: "2"
              TIMEOUT: "200"
              LOG_LEVEL: "INFO"

              # Timeout Configuration
              # High timeout (1 hour) for 32B model entity extraction
              # Entity extraction with large models can take several minutes per chunk
              # Note: LightRAG interprets 0 as 0 seconds, not "no timeout"
              EMBEDDING_TIMEOUT: "3600"
              LLM_TIMEOUT: "3600"
              # Log directory - use emptyDir for ephemeral logs (cloud-native pattern)
              LOG_DIR: "/app/logs"

              # Working directories (PVC mounts)
              WORKING_DIR: "/app/data/rag_storage"
              INPUT_DIR: "/app/data/inputs"
              WORKSPACE: "homelab"

              # LLM Configuration (LiteLLM Gateway with Automatic Fallback)
              # Route LLM calls through LiteLLM for unified API gateway and automatic failover
              # Fallback chain: OpenAI gpt-4o-mini (primary) -> Ollama qwen2.5:32b (local fallback)
              # See: kubernetes/apps/ai/litellm/app/configmap.yaml (router_settings.fallbacks)
              LLM_BINDING: "openai"
              LLM_MODEL: "rag-model"
              OPENAI_API_BASE: "http://litellm.ai.svc.cluster.local:4000/v1"
              # Security: Uses scoped virtual key with model restrictions (NOT admin master key)
              # Key scope: ["rag-model"] - routes to OpenAI (primary) or Ollama (fallback)
              OPENAI_API_KEY:
                valueFrom:
                  secretKeyRef:
                    name: lightrag-litellm-key
                    key: api-key

              # Embedding Configuration (LiteLLM Gateway)
              # Routes embedding calls through LiteLLM for centralized management
              # Uses same API key as LLM calls (requires rag-embedding model access)
              # LiteLLM routes to: ollama/nomic-embed-text (768 dimensions)
              EMBEDDING_BINDING: "openai"
              EMBEDDING_MODEL: "rag-embedding"
              EMBEDDING_BINDING_HOST: "http://litellm.ai.svc.cluster.local:4000/v1"
              EMBEDDING_BINDING_API_KEY:
                valueFrom:
                  secretKeyRef:
                    name: lightrag-litellm-key
                    key: api-key
              EMBEDDING_DIM: "768"

              # Storage Configuration
              LIGHTRAG_KV_STORAGE: "JsonKVStorage"
              LIGHTRAG_VECTOR_STORAGE: "QdrantVectorDBStorage"
              LIGHTRAG_GRAPH_STORAGE: "NetworkXStorage"
              LIGHTRAG_DOC_STATUS_STORAGE: "JsonDocStatusStorage"

              # Qdrant Configuration
              QDRANT_URL: "http://qdrant.ai.svc.cluster.local:6333"
              QDRANT_API_KEY:
                valueFrom:
                  secretKeyRef:
                    name: qdrant-secret
                    key: api-key

              # Disable authentication for internal cluster access
              # External auth handled by Authentik forward auth
              LIGHTRAG_API_KEY: ""

            probes:
              liveness:
                enabled: true
                custom: true
                spec:
                  httpGet:
                    path: /health
                    port: &port 9621
                  initialDelaySeconds: 60
                  periodSeconds: 30
                  timeoutSeconds: 10
                  failureThreshold: 3
              readiness:
                enabled: true
                custom: true
                spec:
                  httpGet:
                    path: /health
                    port: *port
                  initialDelaySeconds: 30
                  periodSeconds: 10
                  timeoutSeconds: 5
                  failureThreshold: 3
            resources:
              requests:
                cpu: 500m
                memory: 1Gi
              limits:
                cpu: 2
                memory: 4Gi

            securityContext:
              allowPrivilegeEscalation: false
              readOnlyRootFilesystem: false
              capabilities:
                drop:
                  - ALL

    defaultPodOptions:
      automountServiceAccountToken: false
      nodeSelector:
        # Target AI workloads node
        kubernetes.io/hostname: k8s-work-10
      annotations:
        # Stakater Reloader: restart pod when secrets change (credential rotation)
        secret.reloader.stakater.com/reload: "lightrag-litellm-key,qdrant-secret"
        security.homelab/network: "Internal only - ClusterIP service with Authentik forward auth"
        security.homelab/storage: "Ceph RBD for RAG data persistence"
      securityContext:
        runAsUser: 1000
        runAsGroup: 1000
        runAsNonRoot: true
        fsGroup: 1000
        fsGroupChangePolicy: OnRootMismatch
        seccompProfile:
          type: RuntimeDefault

    persistence:
      rag:
        enabled: true
        existingClaim: lightrag-rag
        globalMounts:
          - path: /app/data/rag_storage
      input:
        enabled: true
        existingClaim: lightrag-input
        globalMounts:
          - path: /app/data/inputs
      # Ephemeral logs - follows cloud-native pattern (logs to emptyDir, not PVC)
      logs:
        enabled: true
        type: emptyDir
        globalMounts:
          - path: /app/logs

    service:
      app:
        controller: lightrag
        type: ClusterIP
        ports:
          http:
            port: 9621
            protocol: TCP
