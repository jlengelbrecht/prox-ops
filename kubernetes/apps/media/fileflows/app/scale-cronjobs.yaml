---
# Scale FileFlows deployment to 1 at 01:00 local time
# This starts the transcoding window
apiVersion: batch/v1
kind: CronJob
metadata:
  name: fileflows-scale-up
  namespace: media
spec:
  schedule: "0 1 * * *"
  timeZone: "America/New_York"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 3
      template:
        metadata:
          labels:
            app.kubernetes.io/name: fileflows-scale-up
        spec:
          restartPolicy: OnFailure
          serviceAccountName: fileflows-scaler
          automountServiceAccountToken: true
          securityContext:
            runAsUser: 65534  # nobody
            runAsGroup: 65534
            runAsNonRoot: true
            fsGroup: 65534
            seccompProfile:
              type: RuntimeDefault
          containers:
            - name: kubectl
              image: bitnami/kubectl:1.32.0
              imagePullPolicy: IfNotPresent
              command:
                - /bin/sh
                - -c
                - |
                  kubectl scale deployment fileflows -n media --replicas=1
              securityContext:
                allowPrivilegeEscalation: false
                readOnlyRootFilesystem: true
                capabilities:
                  drop:
                    - ALL
              resources:
                requests:
                  cpu: 10m
                  memory: 32Mi
                limits:
                  cpu: 100m
                  memory: 64Mi
---
# Scale FileFlows deployment to 0 at 06:00 local time
# This ends the transcoding window and frees GPU for Plex/Whisper
apiVersion: batch/v1
kind: CronJob
metadata:
  name: fileflows-scale-down
  namespace: media
spec:
  schedule: "0 6 * * *"
  timeZone: "America/New_York"
  successfulJobsHistoryLimit: 3
  failedJobsHistoryLimit: 3
  concurrencyPolicy: Forbid
  jobTemplate:
    spec:
      backoffLimit: 3
      template:
        metadata:
          labels:
            app.kubernetes.io/name: fileflows-scale-down
        spec:
          restartPolicy: OnFailure
          serviceAccountName: fileflows-scaler
          automountServiceAccountToken: true
          securityContext:
            runAsUser: 65534
            runAsGroup: 65534
            runAsNonRoot: true
            fsGroup: 65534
            seccompProfile:
              type: RuntimeDefault
          containers:
            - name: kubectl
              image: bitnami/kubectl:1.32.0
              imagePullPolicy: IfNotPresent
              command:
                - /bin/sh
                - -c
                - |
                  kubectl scale deployment fileflows -n media --replicas=0
              securityContext:
                allowPrivilegeEscalation: false
                readOnlyRootFilesystem: true
                capabilities:
                  drop:
                    - ALL
              resources:
                requests:
                  cpu: 10m
                  memory: 32Mi
                limits:
                  cpu: 100m
                  memory: 64Mi
---
# ServiceAccount for CronJob to scale deployment
apiVersion: v1
kind: ServiceAccount
metadata:
  name: fileflows-scaler
  namespace: media
automountServiceAccountToken: false
---
# Role to allow scaling fileflows deployment
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: fileflows-scaler
  namespace: media
rules:
  - apiGroups: ["apps"]
    resources: ["deployments", "deployments/scale"]
    verbs: ["get", "patch", "update"]
    resourceNames: ["fileflows"]
---
# RoleBinding to grant ServiceAccount the scaling role
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: fileflows-scaler
  namespace: media
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: fileflows-scaler
subjects:
  - kind: ServiceAccount
    name: fileflows-scaler
    namespace: media
